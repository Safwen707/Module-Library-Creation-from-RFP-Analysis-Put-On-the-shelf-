# -*- coding: utf-8 -*-
"""customer_needs_analysis_agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VtNe88wFA_wJX4jCvHNUxFi9JIOXDovs
"""

!pip -q install --upgrade \
    together==1.5.21 \
    pdfplumber \
    python-docx \
    reportlab \
    tqdm

import os, textwrap, json, re
from pathlib import Path
from typing import List
import pdfplumber, docx
from google.colab import files
from tqdm.auto import tqdm
from together import Together

os.environ["TOGETHER_API_KEY"] = "8201d29393384428ba1c32e5e16a55d2d67188d618f94476b26ef0414e59e8dc"

# =========================================
# Upload the RFP document
# =========================================
print("‚¨ÜÔ∏è  Upload a PDF, DOCX, or TXT version of the RFP")
uploaded = files.upload()
fname    = next(iter(uploaded))
print("Received:", fname)

# =========================================
# Load & clean the RFP text
# =========================================
def load_rfp_text(path: str) -> str:
    ext = Path(path).suffix.lower()
    if ext == ".pdf":
        with pdfplumber.open(path) as pdf:
            pages = [p.extract_text() or "" for p in pdf.pages]
        raw = "\n".join(pages)
    elif ext in {".docx", ".doc"}:
        doc  = docx.Document(path)
        raw  = "\n".join(p.text for p in doc.paragraphs)
    else:  # assume plain text
        raw  = Path(path).read_text()


    raw = re.sub(r"\s+\n", "\n", raw)
    raw = re.sub(r"\n{2,}", "\n\n", raw)
    return raw.strip()

rfp_text = load_rfp_text(fname)
print(f"‚úÖ Loaded {len(rfp_text):,} characters of RFP text")


MAX_CHARS = 18_000
if len(rfp_text) > MAX_CHARS:
    print("‚ö†Ô∏è  RFP is long ‚Äì truncating to first", MAX_CHARS, "chars")
    rfp_text = rfp_text[:MAX_CHARS]

# =========================================
# Build the prompt messages
# =========================================
SYSTEM_INSTRUCTION = """
You are a seasoned pre‚Äësales consultant. Given an RFP, you must extract and
synthesize the CLIENT‚ÄôS NEEDS, PAIN POINTS, and SUCCESS CRITERIA.

Deliver a **Customer Needs Report** with these sections:
1. Executive‚ÄØSummary (‚â§‚ÄØ150‚ÄØwords)
2. Detailed Needs:
   ‚Ä¢ Need / Requirement
   ‚Ä¢ Business Value / Impact
3. Implicit Wish‚ÄëList (features not explicitly asked for but strongly implied)
Use professional, concise language.
""".strip()

messages = [
    {"role": "system", "content": SYSTEM_INSTRUCTION},
    {
        "role": "user",
        "content": f"Here is the full RFP:\n\n{rfp_text}"
    },
]

# =========================================
# Call DeepSeek‚ÄëV3
# =========================================
client = Together()

response = client.chat.completions.create(
    model="deepseek-ai/DeepSeek-V3",
    messages=messages,
    stream=True,
    temperature=0.2,
)

print("\n\nüìù **Customer Needs Report**\n")
report_chunks = []

for token in response:
    if hasattr(token, "choices"):
        chunk = token.choices[0].delta.content or ""
        print(chunk, end="", flush=True)
        report_chunks.append(chunk)
report_text = "".join(report_chunks).strip()

# =========================================
#  Export the report as a well-formatted PDF
# =========================================
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.colors import HexColor
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY
from google.colab import files
import re

pdf_path = "customer_needs_report.pdf"

# Create document with better margins
doc = SimpleDocTemplate(
    pdf_path,
    pagesize=A4,
    rightMargin=0.75*inch,
    leftMargin=0.75*inch,
    topMargin=1*inch,
    bottomMargin=0.75*inch
)

# Get base styles and create custom ones
styles = getSampleStyleSheet()

# Custom styles for better formatting
title_style = ParagraphStyle(
    'CustomTitle',
    parent=styles['Heading1'],
    fontSize=24,
    spaceAfter=30,
    alignment=TA_CENTER,
    textColor=HexColor('#2E86AB'),
    fontName='Helvetica-Bold'
)

heading1_style = ParagraphStyle(
    'CustomHeading1',
    parent=styles['Heading1'],
    fontSize=18,
    spaceAfter=18,
    spaceBefore=24,
    textColor=HexColor('#A23B72'),
    fontName='Helvetica-Bold'
)

heading2_style = ParagraphStyle(
    'CustomHeading2',
    parent=styles['Heading2'],
    fontSize=14,
    spaceAfter=12,
    spaceBefore=18,
    textColor=HexColor('#F18F01'),
    fontName='Helvetica-Bold'
)

heading3_style = ParagraphStyle(
    'CustomHeading3',
    parent=styles['Heading3'],
    fontSize=12,
    spaceAfter=8,
    spaceBefore=12,
    textColor=HexColor('#C73E1D'),
    fontName='Helvetica-Bold'
)

body_style = ParagraphStyle(
    'CustomBody',
    parent=styles['Normal'],
    fontSize=11,
    spaceAfter=12,
    alignment=TA_JUSTIFY,
    fontName='Helvetica'
)

bullet_style = ParagraphStyle(
    'CustomBullet',
    parent=styles['Normal'],
    fontSize=10,
    spaceAfter=6,
    leftIndent=20,
    bulletIndent=10,
    fontName='Helvetica'
)

flow = []

def process_text_block(text_block):
    """Process a text block and determine its formatting"""
    text_block = text_block.strip()
    if not text_block:
        return None, None

    # Check for different heading levels based on # symbols
    if text_block.startswith('####'):
        return text_block[4:].strip(), heading3_style
    elif text_block.startswith('###'):
        return text_block[3:].strip(), heading2_style
    elif text_block.startswith('##'):
        return text_block[2:].strip(), heading1_style
    elif text_block.startswith('#'):
        return text_block[1:].strip(), title_style

    # Check for bullet points
    elif text_block.startswith('- ') or text_block.startswith('‚Ä¢ '):
        return text_block[2:].strip(), bullet_style
    elif re.match(r'^\d+\.\s', text_block):
        return text_block, bullet_style

    # Regular paragraph
    else:
        return text_block, body_style

# Process the report text
paragraphs = report_text.split('\n\n')

for i, para in enumerate(paragraphs):
    if not para.strip():
        continue

    # Handle multi-line paragraphs that might contain formatting
    lines = para.split('\n')

    for line in lines:
        processed_text, style = process_text_block(line)

        if processed_text and style:
            # Clean up the text - convert newlines to line breaks for HTML
            clean_text = processed_text.replace('\n', '<br/>')

            # Add some special formatting for emphasis
            clean_text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_text)  # Bold
            clean_text = re.sub(r'\*(.*?)\*', r'<i>\1</i>', clean_text)      # Italic

            # Create paragraph
            flow.append(Paragraph(clean_text, style))

            # Add extra space after headings
            if style in [title_style, heading1_style]:
                flow.append(Spacer(1, 12))
            elif style in [heading2_style, heading3_style]:
                flow.append(Spacer(1, 8))

# Build the PDF
try:
    doc.build(flow)
    print(f"‚úÖ Well-formatted PDF saved ‚Üí {pdf_path}")

    # Offer download in Colab
    files.download(pdf_path)

except Exception as e:
    print(f"‚ùå Error creating PDF: {e}")
    print("Falling back to simpler formatting...")

    # Fallback: simpler but still better formatted version
    flow = []
    for para in report_text.split("\n\n"):
        if para.strip():
            clean_para = para.replace("\n", "<br/>")
            # Apply basic formatting
            if para.startswith('#'):
                flow.append(Paragraph(clean_para, heading1_style))
            else:
                flow.append(Paragraph(clean_para, body_style))
            flow.append(Spacer(1, 8))

    doc.build(flow)
    print(f"‚úÖ PDF saved with basic formatting ‚Üí {pdf_path}")
    files.download(pdf_path)

