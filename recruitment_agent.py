# -*- coding: utf-8 -*-
"""recruitment-agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10mhJ3oTvXfu-MtA042BoUN7RxbjtHdS9
"""

!pip install transformers torch pandas numpy scikit-learn nltk PyPDF2 pdfplumber

import pandas as pd
import numpy as np
import re
import json
import torch
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Transformers et Gemini
from transformers import AutoTokenizer, AutoModelForCausalLM, GenerationConfig
import torch.nn.functional as F

# PDF et text processing
import PyPDF2
import pdfplumber
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import nltk
from collections import Counter, defaultdict

# T√©l√©chargement NLTK si n√©cessaire
try:
    nltk.data.find('tokenizers/punkt')
    nltk.data.find('corpora/stopwords')
except LookupError:
    nltk.download('punkt', quiet=True)
    nltk.download('stopwords', quiet=True)

from nltk.corpus import stopwords

print("‚úÖ Biblioth√®ques import√©es avec succ√®s")

#Modify this code bit
#Should add ur own key here

from kaggle_secrets import UserSecretsClient
user_secrets = UserSecretsClient()
HF_key = user_secrets.get_secret("HF_API_KEY")

def configurer_huggingface():
    """Configure l'authentification Hugging Face pour acc√©der √† Gemma"""

    print("üîê CONFIGURATION HUGGING FACE")
    print("-" * 35)

    try:
        from huggingface_hub import login, HfApi
        import os

        # V√©rifier si un token existe d√©j√†
        token_existant = HF_key

        if token_existant:
            print("‚úÖ Token Hugging Face trouv√© dans les variables d'environnement")
            try:
                login(token=token_existant, add_to_git_credential=False)
                print("‚úÖ Authentification r√©ussie avec le token existant")
                return True
            except Exception as e:
                print(f"‚ùå √âchec avec le token existant: {e}")

        # Demander le token √† l'utilisateur
        print("\nüìã √âTAPES POUR OBTENIR VOTRE TOKEN HUGGING FACE:")
        print("1. Allez sur https://huggingface.co/settings/tokens")
        print("2. Cr√©ez un nouveau token (Read access suffit)")
        print("3. Copiez le token g√©n√©r√©")
        print("4. Collez-le ci-dessous")
        print("\nüí° Le token ressemble √†: hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")

        token = input("\nüîë Entrez votre token Hugging Face: ").strip()

        if not token.startswith('hf_'):
            print("‚ö†Ô∏è  Attention: Le token devrait commencer par 'hf_'")
            confirmation = input("Continuer quand m√™me? (o/n): ").lower()
            if confirmation != 'o':
                return False

        # Tenter la connexion
        login(token=token, add_to_git_credential=False)

        # V√©rifier l'acc√®s √† Gemma
        api = HfApi()
        try:
            model_info = api.model_info("google/gemma-2b-it", token=token)
            print("‚úÖ Acc√®s confirm√© au mod√®le Gemma!")

            # Sauvegarder le token pour les prochaines fois
            choix_sauvegarde = input("üíæ Sauvegarder le token localement? (o/n): ").lower()
            if choix_sauvegarde == 'o':
                os.environ['HF_TOKEN'] = token
                print("‚úÖ Token sauvegard√© pour cette session")

            return True

        except Exception as e:
            print(f"‚ùå Erreur d'acc√®s √† Gemma: {e}")
            print("üí° V√©rifiez que vous avez accept√© les conditions d'utilisation:")
            print("   https://huggingface.co/google/gemma-2b-it")
            return False

    except ImportError:
        print("‚ùå Erreur: huggingface_hub non install√©")
        print("üì¶ Installez avec: pip install huggingface_hub")
        return False

    except Exception as e:
        print(f"‚ùå Erreur inattendue: {e}")
        return False

def utiliser_modele_alternatif():
    """Propose des mod√®les alternatifs qui ne n√©cessitent pas d'authentification"""

    print("\nüîÑ MOD√àLES ALTERNATIFS DISPONIBLES")
    print("-" * 40)

    modeles_libres = {
        "microsoft/DialoGPT-medium": {
            "description": "Mod√®le conversationnel Microsoft",
            "avantages": "Pas d'auth requise, bon pour dialogue",
            "inconvenients": "Moins sp√©cialis√© pour l'analyse"
        },
        "distilbert-base-uncased": {
            "description": "Version all√©g√©e de BERT",
            "avantages": "Rapide, pas d'auth, bon pour classification",
            "inconvenients": "Pas g√©n√©ratif, limit√© pour rapports"
        },
        "gpt2": {
            "description": "GPT-2 d'OpenAI (ancien mais fonctionnel)",
            "avantages": "Pas d'auth, g√©n√©ratif, bien document√©",
            "inconvenients": "Moins performant que Gemma"
        }
    }

    print("Mod√®les disponibles sans authentification:")
    for i, (nom, info) in enumerate(modeles_libres.items(), 1):
        print(f"\n{i}. {nom}")
        print(f"   Description: {info['description']}")
        print(f"   ‚úÖ Avantages: {info['avantages']}")
        print(f"   ‚ö†Ô∏è  Limites: {info['inconvenients']}")

    print(f"\n4. Continuer sans Gemini (analyse de base uniquement)")

    choix = input(f"\nChoisissez une option (1-4): ").strip()

    if choix == "1":
        return "microsoft/DialoGPT-medium"
    elif choix == "2":
        return "distilbert-base-uncased"
    elif choix == "3":
        return "gpt2"
    elif choix == "4":
        return None  # Mode sans Gemini
    else:
        print("Choix invalide, utilisation de GPT-2 par d√©faut")
        return "gpt2"

def resoudre_probleme_authentification():
    """Fonction principale pour r√©soudre les probl√®mes d'authentification"""

    print("üö® PROBL√àME D'AUTHENTIFICATION D√âTECT√â")
    print("=" * 45)

    print("\nCe probl√®me survient car Gemma n√©cessite:")
    print("1. ‚úÖ Un compte Hugging Face gratuit")
    print("2. ‚úÖ Accepter les conditions d'utilisation du mod√®le")
    print("3. ‚úÖ Un token d'authentification")

    print(f"\nüõ†Ô∏è  SOLUTIONS DISPONIBLES:")
    print("1. Configurer l'authentification Hugging Face (RECOMMAND√â)")
    print("2. Utiliser un mod√®le alternatif sans authentification")
    print("3. Continuer sans Gemini (analyse de base uniquement)")

    choix = input(f"\nQue souhaitez-vous faire? (1-3): ").strip()

    if choix == "1":
        if configurer_huggingface():
            return "google/gemma-2b-it"  # Mod√®le original
        else:
            print("\n‚ùå Configuration √©chou√©e")
            return utiliser_modele_alternatif()

    elif choix == "2":
        return utiliser_modele_alternatif()

    elif choix == "3":
        print("‚úÖ Continuation en mode analyse de base uniquement")
        return None

    else:
        print("Choix invalide, utilisation du mode de base")
        return None

print("‚úÖ Configuration d'authentification pr√™te")

@dataclass
class RFPFrancais:
    """Structure pour RFP fran√ßais"""
    titre: str
    entreprise: str
    secteur: str
    description: str
    competences_obligatoires: List[str]
    competences_souhaitees: List[str]
    certifications_requises: List[str]
    experience_min_ans: int
    types_contrat: List[str]
    localisation: str
    delais: str
    budget: str
    texte_brut: str
    score_confiance: float
    niveau_poste: str = "Confirm√©"
    type_role: str = "Technique"

@dataclass
class ProfilCandidat:
    """Profil candidat analys√©"""
    id: int
    categorie: str
    texte_cv: str
    competences_trouvees: List[str]
    certifications: List[str]
    experience_ans: int
    score_match: float
    couverture_obligatoire: float
    couverture_souhaitee: float
    match_certifications: bool
    match_experience: bool
    contrat_recommande: str
    cout_estime: int
    forces: List[str]
    lacunes: List[str]
    niveau_risque: str
    recommandation_gemini: str = ""
    adequation_technique: int = 0
    pertinence_experience: int = 0
    axes_entretien: List[str] = None
    besoins_integration: List[str] = None

class AgentGeminiFrancais:
    """Agent Gemini optimis√© pour le recrutement fran√ßais"""

    def __init__(self, modele: str = "google/gemma-2b-it"):
        self.nom_modele = modele
        self.device = self._configurer_device()

        print(f"üîÑ Chargement du mod√®le Gemini : {modele}")
        print(f"üì± Device utilis√© : {self.device}")

        # Chargement du mod√®le
        self.tokenizer = AutoTokenizer.from_pretrained(
            modele, trust_remote_code=True
        )

        self.model = AutoModelForCausalLM.from_pretrained(
            modele,
            torch_dtype=torch.float16 if self.device != "cpu" else torch.float32,
            device_map="auto" if self.device != "cpu" else None,
            trust_remote_code=True
        )

        # Configuration pad token
        if self.tokenizer.pad_token is None:
            self.tokenizer.pad_token = self.tokenizer.eos_token

        # Configuration g√©n√©ration
        self.config_generation = GenerationConfig(
            max_new_tokens=1024,
            temperature=0.3,
            top_p=0.9,
            do_sample=True,
            pad_token_id=self.tokenizer.eos_token_id
        )

        print("‚úÖ Mod√®le Gemini charg√© avec succ√®s")

    def _configurer_device(self) -> str:
        """Configure le device optimal"""
        if torch.cuda.is_available():
            device = "cuda"
            print(f"üöÄ CUDA disponible : {torch.cuda.get_device_name()}")
        elif hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
            device = "mps"
            print("üçé MPS (Apple Silicon) disponible")
        else:
            device = "cpu"
            print("üíª Utilisation CPU")
        return device

    def generer_reponse(self, prompt: str, tokens_max: int = 1024) -> str:
        """G√©n√®re une r√©ponse avec Gemini"""

        # Format prompt pour Gemma
        prompt_formate = f"<start_of_turn>user\n{prompt}<end_of_turn>\n<start_of_turn>model\n"

        # Tokenisation
        inputs = self.tokenizer(
            prompt_formate,
            return_tensors="pt",
            truncation=True,
            max_length=2048
        )

        if self.device != "cpu":
            inputs = inputs.to(self.device)

        # G√©n√©ration
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                generation_config=self.config_generation,
                max_new_tokens=tokens_max,
                pad_token_id=self.tokenizer.eos_token_id
            )

        # D√©codage
        reponse = self.tokenizer.decode(
            outputs[0][inputs.input_ids.shape[1]:],
            skip_special_tokens=True
        )

        return reponse.strip()

    def analyser_rfp_francais(self, texte_rfp: str, donnees_extraites: dict) -> Dict:
        """Analyse la qualit√© d'extraction du RFP fran√ßais"""

        prompt = f"""
Tu es un expert en recrutement fran√ßais. Analyse ce RFP fran√ßais et √©value la qualit√© de l'extraction.

TEXTE RFP (extrait):
{texte_rfp[:2000]}...

DONN√âES EXTRAITES:
- Titre: {donnees_extraites.get('titre', 'Non trouv√©')}
- Comp√©tences obligatoires: {', '.join(donnees_extraites.get('competences_obligatoires', [])[:8])}
- Comp√©tences souhait√©es: {', '.join(donnees_extraites.get('competences_souhaitees', [])[:5])}
- Exp√©rience requise: {donnees_extraites.get('experience_min_ans', 0)} ans
- Certifications: {', '.join(donnees_extraites.get('certifications_requises', [])[:3])}

T√ÇCHES:
1. Noter la qualit√© de l'extraction (1-10)
2. Identifier les exigences manquantes importantes
3. Sugg√©rer 3-5 comp√©tences additionnelles pertinentes
4. Classer le niveau du poste (Junior/Confirm√©/Senior/Expert)
5. Identifier le type de r√¥le (Technique/Management/Conseil/Commercial)

Format de r√©ponse:
QUALITE: [1-10]
MANQUANT: [exigences critiques manquantes ou "Rien"]
COMPETENCES_SUPP: [3-5 comp√©tences sugg√©r√©es]
NIVEAU: [Junior/Confirm√©/Senior/Expert]
TYPE_ROLE: [Technique/Management/Conseil/Commercial]
"""

        reponse = self.generer_reponse(prompt, 512)
        return self._parser_analyse_rfp(reponse)

    def analyser_candidat_francais(self, candidat: dict, rfp: dict) -> Dict:
        """Analyse approfondie d'un candidat fran√ßais"""

        prompt = f"""
Tu es un consultant RH expert. Analyse ce candidat fran√ßais pour le poste.

POSTE:
- Titre: {rfp.get('titre', 'Poste inconnu')}
- Comp√©tences cl√©s: {', '.join(rfp.get('competences_obligatoires', [])[:8])}
- Exp√©rience: {rfp.get('experience_min_ans', 0)}+ ans
- Secteur: {rfp.get('secteur', 'Non sp√©cifi√©')}

CANDIDAT:
- Cat√©gorie: {candidat.get('categorie', 'Inconnue')}
- Exp√©rience: {candidat.get('experience_ans', 0)} ans
- Comp√©tences: {', '.join(candidat.get('competences_trouvees', [])[:8])}
- Score: {candidat.get('score_match', 0):.1%}
- CV (extrait): {candidat.get('texte_cv', '')[:400]}...

ANALYSE DEMAND√âE:
1. Ad√©quation technique (1-10)
2. Pertinence exp√©rience (1-10)
3. Top 3 forces du candidat
4. Top 3 points d'attention
5. Axes d'entretien prioritaires
6. Besoins d'int√©gration/formation
7. Recommandation finale

Format:
TECHNIQUE: [1-10]
EXPERIENCE: [1-10]
FORCES: [3 forces principales]
POINTS_ATTENTION: [3 points d'attention]
ENTRETIEN: [3 axes d'entretien]
INTEGRATION: [besoins formation/accompagnement]
RECOMMANDATION: [Embaucher/Evaluer/Rejeter]
JUSTIFICATION: [explication courte]
"""

        reponse = self.generer_reponse(prompt, 1024)
        return self._parser_analyse_candidat(reponse)

    def generer_rapport_executif(self, top_candidats: List, rfp_data: dict, donnees_marche: dict) -> str:
        """G√©n√®re un rapport ex√©cutif fran√ßais avec gestion d'erreurs"""

        try:
            candidates_summary = []
            for i, candidat in enumerate(top_candidats[:5], 1):
                # V√©rifier si c'est un objet ProfilCandidat ou un dictionnaire
                if hasattr(candidat, 'id'):  # C'est un objet ProfilCandidat
                    candidates_summary.append(
                        f"{i}. Candidat #{candidat.id} ({candidat.categorie}) - "
                        f"{candidat.score_match:.1%} - {candidat.experience_ans} ans"
                    )
                else:  # C'est un dictionnaire
                    candidates_summary.append(
                        f"{i}. Candidat #{candidat.get('id', 'N/A')} ({candidat.get('categorie', 'N/A')}) - "
                        f"{candidat.get('score_match', 0):.1%} - {candidat.get('experience_ans', 0)} ans"
                    )

            prompt = f"""
Tu es un consultant senior pr√©parant un rapport ex√©cutif pour un client fran√ßais.

CONTEXTE MISSION:
- Poste: {rfp_data.get('titre', 'Poste inconnu')}
- Entreprise: {rfp_data.get('entreprise', 'Entreprise inconnue')}
- Secteur: {rfp_data.get('secteur', 'Non sp√©cifi√©')}
- Comp√©tences cl√©s: {', '.join(rfp_data.get('competences_obligatoires', [])[:6])}
- Niveau: {rfp_data.get('experience_min_ans', 0)}+ ans

CANDIDATS IDENTIFI√âS:
{chr(10).join(candidates_summary)}

MARCH√â:
- Total analys√©: {donnees_marche.get('total_analyses', 0)}
- Score moyen: {donnees_marche.get('score_moyen', 0):.1%}
- Avec certifications: {donnees_marche.get('avec_certifications', 0)}

G√©n√®re un rapport ex√©cutif professionnel fran√ßais incluant:

1. SYNTH√àSE EX√âCUTIVE (2-3 phrases)
2. √âTAT DU MARCH√â (disponibilit√© talents)
3. CANDIDATS PRIORITAIRES (√©valuation de chacun)
4. STRAT√âGIE RECRUTEMENT (approche recommand√©e)
5. FACTEURS DE RISQUE (d√©fis potentiels)
6. BUDGET & PLANNING
7. ACTIONS RECOMMAND√âES

Style: professionnel, concis, ax√© business.
"""

            response = self.generer_reponse(prompt, max_tokens=1024)
            return response

        except Exception as e:
            print(f"Erreur dans generer_rapport_executif: {e}")

    def _parser_analyse_rfp(self, reponse: str) -> Dict:
        """Parse la r√©ponse d'analyse RFP"""
        analyse = {
            'score_qualite': 5,
            'exigences_manquantes': [],
            'competences_supplementaires': [],
            'niveau_poste': 'Confirm√©',
            'type_role': 'Technique'
        }

        try:
            lignes = reponse.split('\n')
            for ligne in lignes:
                ligne = ligne.strip()
                if ligne.startswith('QUALITE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['score_qualite'] = int(score[0])

                elif ligne.startswith('MANQUANT:'):
                    manquant = ligne.replace('MANQUANT:', '').strip()
                    if manquant and manquant.lower() not in ['rien', 'non', 'aucun']:
                        analyse['exigences_manquantes'] = [m.strip() for m in manquant.split(',')]

                elif ligne.startswith('COMPETENCES_SUPP:'):
                    comp = ligne.replace('COMPETENCES_SUPP:', '').strip()
                    if comp:
                        analyse['competences_supplementaires'] = [c.strip() for c in comp.split(',')]

                elif ligne.startswith('NIVEAU:'):
                    niveau = ligne.replace('NIVEAU:', '').strip()
                    if niveau:
                        analyse['niveau_poste'] = niveau

                elif ligne.startswith('TYPE_ROLE:'):
                    type_role = ligne.replace('TYPE_ROLE:', '').strip()
                    if type_role:
                        analyse['type_role'] = type_role

        except Exception as e:
            print(f"Attention: Erreur parsing RFP: {e}")

        return analyse

    def _parser_analyse_candidat(self, reponse: str) -> Dict:
        """Parse la r√©ponse d'analyse candidat"""
        analyse = {
            'adequation_technique': 5,
            'pertinence_experience': 5,
            'forces': [],
            'points_attention': [],
            'axes_entretien': [],
            'besoins_integration': [],
            'recommandation': 'Evaluer',
            'justification': 'Analyse standard'
        }

        try:
            lignes = reponse.split('\n')
            for ligne in lignes:
                ligne = ligne.strip()
                if ligne.startswith('TECHNIQUE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['adequation_technique'] = int(score[0])

                elif ligne.startswith('EXPERIENCE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['pertinence_experience'] = int(score[0])

                elif ligne.startswith('FORCES:'):
                    forces = ligne.replace('FORCES:', '').strip()
                    if forces:
                        analyse['forces'] = [f.strip() for f in forces.split(',')][:3]

                elif ligne.startswith('POINTS_ATTENTION:'):
                    points = ligne.replace('POINTS_ATTENTION:', '').strip()
                    if points:
                        analyse['points_attention'] = [p.strip() for p in points.split(',')][:3]

                elif ligne.startswith('ENTRETIEN:'):
                    entretien = ligne.replace('ENTRETIEN:', '').strip()
                    if entretien:
                        analyse['axes_entretien'] = [e.strip() for e in entretien.split(',')][:3]

                elif ligne.startswith('INTEGRATION:'):
                    integration = ligne.replace('INTEGRATION:', '').strip()
                    if integration:
                        analyse['besoins_integration'] = [i.strip() for i in integration.split(',')][:3]

                elif ligne.startswith('RECOMMANDATION:'):
                    rec = ligne.replace('RECOMMANDATION:', '').strip()
                    if rec:
                        analyse['recommandation'] = rec

                elif ligne.startswith('JUSTIFICATION:'):
                    just = ligne.replace('JUSTIFICATION:', '').strip()
                    if just:
                        analyse['justification'] = just

        except Exception as e:
            print(f"Attention: Erreur parsing candidat: {e}")

        return analyse

print("‚úÖ Agent Gemini Fran√ßais pr√™t")

class ParseurRFPFrancais:
    """Parser optimis√© pour les RFPs fran√ßais"""

    def __init__(self):
        # Patterns fran√ßais pour comp√©tences
        self.patterns_competences = {
            'obligatoires': [
                r'comp√©tences\s*(?:exig√©es?|obligatoires?|requises?|imp√©ratives?)[:\s]*([^.]{1,200})',
                r'(?:pr√©requis|pr√©-requis)\s*(?:obligatoires?)?[:\s]*([^.]{1,200})',
                r'ma√Ætrise\s*(?:obligatoire|requise|exig√©e)[:\s]*([^.]{1,200})',
                r'indispensable[:\s]*([^.]{1,200})'
            ],
            'souhaitees': [
                r'comp√©tences\s*(?:souhait√©es?|d√©sir√©es?|appr√©ci√©es?)[:\s]*([^.]{1,200})',
                r'(?:atouts?|plus)[:\s]*([^.]{1,200})',
                r'serait\s*un\s*plus[:\s]*([^.]{1,200})',
                r'id√©alement[:\s]*([^.]{1,200})'
            ],
            'techniques': [
                r'technologies?\s*(?:utilis√©es?|requises?)[:\s]*([^.]{1,200})',
                r'outils?[:\s]*([^.]{1,200})',
                r'langages?[:\s]*([^.]{1,200})',
                r'stack\s*technique[:\s]*([^.]{1,200})'
            ]
        }

        # Comp√©tences techniques communes
        self.competences_communes = [
            'python', 'java', 'javascript', 'react', 'angular', 'vue', 'node.js',
            'sql', 'mysql', 'postgresql', 'mongodb', 'docker', 'kubernetes',
            'aws', 'azure', 'gcp', 'git', 'jenkins', 'agile', 'scrum',
            'machine learning', 'ia', 'data science', 'big data',
            'rgpd', 'gdpr', 'cybers√©curit√©', 'audit', 'conformit√©', 'dpo',
            'gestion de projet', 'management', 'leadership', 'communication'
        ]

        # Patterns exp√©rience
        self.patterns_experience = [
            r'(\d+)\s*(?:ans?|ann√©es?)\s*(?:d[\'e]\s*)?(?:exp√©riences?)',
            r'(?:exp√©riences?)\s*(?:de\s*)?(\d+)\s*(?:ans?|ann√©es?)',
            r'minimum\s*(\d+)\s*(?:ans?|ann√©es?)',
            r'au\s*moins\s*(\d+)\s*(?:ans?|ann√©es?)'
        ]

        # Secteurs fran√ßais
        self.secteurs_francais = {
            'IT/Tech': ['informatique', 'technologie', 'digital', 'num√©rique'],
            'Public': ['public', 'administration', 'collectivit√©', 'mairie', 'minist√®re'],
            'Finance': ['banque', 'finance', 'assurance', 'gestion'],
            'Sant√©': ['sant√©', 'm√©dical', 'pharmaceutique', 'h√¥pital'],
            'Conseil': ['conseil', 'consulting', 'expertise', 'audit'],
            'Industrie': ['industrie', 'manufacturier', 'production']
        }

    def extraire_texte_pdf(self, chemin_pdf: str) -> str:
        """Extrait le texte d'un PDF fran√ßais"""
        texte = ""

        try:
            with pdfplumber.open(chemin_pdf) as pdf:
                for page in pdf.pages:
                    texte_page = page.extract_text()
                    if texte_page:
                        texte += texte_page + "\n"
        except Exception as e:
            print(f"Erreur pdfplumber: {e}")
            try:
                with open(chemin_pdf, 'rb') as fichier:
                    lecteur_pdf = PyPDF2.PdfReader(fichier)
                    for page in lecteur_pdf.pages:
                        texte += page.extract_text() + "\n"
            except Exception as e2:
                raise Exception(f"Impossible d'extraire le PDF: {e2}")

        return texte

    def analyser_rfp_complet(self, chemin_pdf: str) -> RFPFrancais:
        """Analyse compl√®te d'un RFP fran√ßais"""

        # Extraction texte
        texte_brut = self.extraire_texte_pdf(chemin_pdf)
        texte_nettoye = self._nettoyer_texte_francais(texte_brut)

        # Extractions
        titre = self._extraire_titre(texte_nettoye)
        entreprise = self._extraire_entreprise(texte_nettoye)
        secteur = self._extraire_secteur(texte_nettoye)
        description = self._extraire_description(texte_nettoye)

        comp_obligatoires = self._extraire_competences(texte_nettoye, 'obligatoires')
        comp_souhaitees = self._extraire_competences(texte_nettoye, 'souhaitees')
        comp_techniques = self._extraire_competences(texte_nettoye, 'techniques')

        # Fusion comp√©tences si n√©cessaire
        if not comp_obligatoires and comp_techniques:
            comp_obligatoires = comp_techniques[:10]

        certifications = self._extraire_certifications(texte_nettoye)
        experience_ans = self._extraire_experience(texte_nettoye)
        types_contrat = self._extraire_types_contrat(texte_nettoye)
        localisation = self._extraire_localisation(texte_nettoye)
        delais = self._extraire_delais(texte_nettoye)
        budget = self._extraire_budget(texte_nettoye)

        # Score de confiance
        score_confiance = self._calculer_confiance(titre, comp_obligatoires, experience_ans)

        return RFPFrancais(
            titre=titre,
            entreprise=entreprise,
            secteur=secteur,
            description=description,
            competences_obligatoires=comp_obligatoires,
            competences_souhaitees=comp_souhaitees,
            certifications_requises=certifications,
            experience_min_ans=experience_ans,
            types_contrat=types_contrat,
            localisation=localisation,
            delais=delais,
            budget=budget,
            texte_brut=texte_brut,
            score_confiance=score_confiance
        )

    def _nettoyer_texte_francais(self, texte: str) -> str:
        """Nettoie le texte fran√ßais"""
        import unicodedata
        texte = unicodedata.normalize('NFKD', texte)
        texte = re.sub(r'\s+', ' ', texte)
        return texte.strip()

    def _extraire_titre(self, texte: str) -> str:
        """Extrait le titre du poste"""
        lignes = texte.split('\n')[:15]

        indicateurs = ['poste', 'mission', 'offre', 'd√©veloppeur', 'ing√©nieur', 'consultant', 'chef', 'responsable']

        for ligne in lignes:
            if any(ind in ligne.lower() for ind in indicateurs) and len(ligne.strip()) > 10:
                return re.sub(r'[^\w\s\-√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]', '', ligne).strip()[:150]

        return "Poste non identifi√©"

    def _extraire_competences(self, texte: str, type_comp: str) -> List[str]:
        """Extrait les comp√©tences selon le type"""
        competences = []
        texte_lower = texte.lower()

        patterns = self.patterns_competences.get(type_comp, [])

        for pattern in patterns:
            matches = re.finditer(pattern, texte_lower, re.IGNORECASE | re.DOTALL)
            for match in matches:
                comp_text = match.group(1)
                competences_parsees = self._parser_liste_competences(comp_text)
                competences.extend(competences_parsees)

        # Ajout comp√©tences communes trouv√©es
        for comp in self.competences_communes:
            if comp.lower() in texte_lower and comp not in competences:
                competences.append(comp)

        return list(set([c.strip() for c in competences if len(c.strip()) > 2]))[:20]

    def _parser_liste_competences(self, texte_comp: str) -> List[str]:
        """Parse une liste de comp√©tences"""
        separateurs = [',', ';', '‚Ä¢', '-', '\n', ' et ', ' ou ']

        competences = [texte_comp]
        for sep in separateurs:
            nouvelles_comp = []
            for comp in competences:
                nouvelles_comp.extend(comp.split(sep))
            competences = nouvelles_comp

        # Nettoyage
        competences_nettoyees = []
        for comp in competences:
            comp = comp.strip()
            comp = re.sub(r'^(?:ma√Ætrise|connaissance|exp√©rience)\s+(?:de\s+|en\s+)?', '', comp, flags=re.IGNORECASE)
            comp = re.sub(r'\s*\([^)]*\)', '', comp)

            if 2 <= len(comp) <= 50:
                competences_nettoyees.append(comp)

        return competences_nettoyees

    def _extraire_experience(self, texte: str) -> int:
        """Extrait les ann√©es d'exp√©rience"""
        annees = []
        for pattern in self.patterns_experience:
            matches = re.findall(pattern, texte.lower())
            for match in matches:
                try:
                    annees.append(int(match))
                except ValueError:
                    continue
        return max(annees) if annees else 0

    def _extraire_entreprise(self, texte: str) -> str:
        """Extrait le nom de l'entreprise"""
        lignes = texte.split('\n')[:20]

        indicateurs = ['soci√©t√©', 'entreprise', 'groupe', 'cabinet', 'sarl', 'sas']

        for ligne in lignes:
            if any(ind in ligne.lower() for ind in indicateurs):
                entreprise = re.sub(r'[^\w\s\-√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]', '', ligne).strip()
                if 3 < len(entreprise) < 100:
                    return entreprise

        return "Entreprise non identifi√©e"

    def _extraire_secteur(self, texte: str) -> str:
        """Extrait le secteur d'activit√©"""
        texte_lower = texte.lower()

        for secteur, mots_cles in self.secteurs_francais.items():
            if any(mot in texte_lower for mot in mots_cles):
                return secteur

        return "Secteur non identifi√©"

    def _extraire_description(self, texte: str) -> str:
        """Extrait la description du poste"""
        patterns = [
            r'(?:description|contexte|mission).*?(?=(?:comp√©tences|qualifications|profil))',
            r'(?:missions?|r√¥les?).*?(?=(?:comp√©tences|qualifications))'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower(), re.DOTALL)
            if match and len(match.group()) > 50:
                return match.group().strip()[:500]

        return "Description non extraite"

    def _extraire_certifications(self, texte: str) -> List[str]:
        """Extrait les certifications"""
        patterns = [
            r'certifications?\s*(?:requises?|exig√©es?)[:\s]*([^.]{1,100})',
            r'dipl√¥mes?\s*(?:requis|exig√©s)[:\s]*([^.]{1,100})'
        ]

        certifications = []
        for pattern in patterns:
            matches = re.finditer(pattern, texte.lower())
            for match in matches:
                cert_text = match.group(1)
                certifications.extend(self._parser_liste_competences(cert_text))

        return list(set(certifications))[:5]

    def _extraire_types_contrat(self, texte: str) -> List[str]:
        """Extrait les types de contrat"""
        contrats_map = {
            'cdi': 'CDI', 'cdd': 'CDD', 'freelance': 'Freelance',
            'stage': 'Stage', 'alternance': 'Alternance', 'expert': 'Expert'
        }

        contrats = []
        texte_lower = texte.lower()

        for cle, valeur in contrats_map.items():
            if cle in texte_lower:
                contrats.append(valeur)

        return list(set(contrats)) if contrats else ['CDI', 'CDD']

    def _extraire_localisation(self, texte: str) -> str:
        """Extrait la localisation"""
        patterns = [
            r'(?:lieu|localisation|r√©gion)[:\s]*([^.\n]{1,50})',
            r'(?:paris|lyon|marseille|toulouse|nice|bordeaux|lille)',
            r'\d{5}\s*[a-zA-Z√Ä-√ø]+',
            r'(?:t√©l√©travail|remote|hybride)'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                if match.groups():
                    return match.group(1).strip().title()
                else:
                    return match.group().strip().title()

        return "Localisation non sp√©cifi√©e"

    def _extraire_delais(self, texte: str) -> str:
        """Extrait les d√©lais"""
        patterns = [
            r'(?:dur√©e|d√©lai|planning)[:\s]*([^.\n]{1,100})',
            r'(\d+)\s*(?:mois|semaines?)',
            r'(?:d√©but|d√©marrage)[:\s]*([^.\n]{1,50})'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                delai = match.group(1 if match.groups() else 0).strip()
                if delai and len(delai) > 3:
                    return delai

        return "D√©lai non sp√©cifi√©"

    def _extraire_budget(self, texte: str) -> str:
        """Extrait le budget"""
        patterns = [
            r'(?:salaire|r√©mun√©ration|budget)[:\s]*([^.\n]{1,100})',
            r'‚Ç¨\s*[\d\s,]+',
            r'\d+\s*k‚Ç¨'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                budget = match.group(1 if match.groups() else 0).strip()
                if budget and len(budget) > 3:
                    return budget

        return "Budget non sp√©cifi√©"

    def _calculer_confiance(self, titre: str, competences: List[str], experience: int) -> float:
        """Calcule le score de confiance d'extraction"""
        score = 0.0

        if titre and titre != "Poste non identifi√©":
            score += 0.3

        if competences:
            score += 0.4
            if len(competences) >= 5:
                score += 0.1

        if experience > 0:
            score += 0.2

        return min(score, 1.0)

print("‚úÖ Parser RFP Fran√ßais pr√™t")

def analyse_recrutement_francais(pdf_path: str, csv_path: str = "UpdatedResumeDataSet.csv",
                                gemini_model: str = "google/gemma-2b-it"):
    """Fonction principale d'analyse de recrutement fran√ßais"""

    print("üöÄ D√âMARRAGE DE L'ANALYSE DE RECRUTEMENT FRAN√áAIS")
    print("=" * 65)

    try:
        # Initialisation du syst√®me
        system = FrenchRecruitmentSystem(gemini_model)

        # Analyse du RFP fran√ßais
        print("\nüìÑ Analyse du RFP fran√ßais...")
        rfp_data = system.analyze_french_rfp_complete(pdf_path)

        print(f"‚úÖ Analyse RFP termin√©e:")
        print(f"   Titre: {rfp_data['title']}")
        print(f"   Entreprise: {rfp_data['company']}")
        print(f"   Secteur: {rfp_data['sector']}")
        print(f"   Score qualit√© Gemini: {rfp_data.get('gemini_quality_score', 0)}/10")
        print(f"   Niveau: {rfp_data.get('gemini_difficulty_level', 'Non d√©fini')}")
        print(f"   Comp√©tences trouv√©es: {len(rfp_data['mandatory_skills'])}")

        # Chargement des candidats
        print(f"\nüìä Chargement des candidats depuis {csv_path}...")
        df = pd.read_csv(csv_path)
        candidates_data = []

        for idx, row in df.iterrows():
            candidates_data.append({
                'id': idx,
                'category': row['Category'],
                'resume_text': row['Resume']
            })

        print(f"‚úÖ {len(candidates_data)} candidats charg√©s")

        # Analyse des candidats
        print(f"\nü§ñ Analyse des candidats avec Gemini fran√ßais...")
        analyzed_candidates = system.analyze_candidates_french(candidates_data, rfp_data)

        # Tri par score
        analyzed_candidates.sort(key=lambda x: x['match_score'], reverse=True)
        top_candidates = analyzed_candidates[:15]

        print(f"‚úÖ Analyse termin√©e")

        # G√©n√©ration des donn√©es de march√©
        market_data = system.generate_french_market_data(analyzed_candidates)

        # G√©n√©ration du rapport final
        print(f"\nüìã G√©n√©ration du rapport ex√©cutif fran√ßais...")
        try:
            final_report = system.gemini.generate_french_executive_report(
                top_candidates, rfp_data, market_data
            )
        except Exception as e:
            print(f"Attention: G√©n√©ration rapport Gemini √©chou√©e: {e}")
            final_report = "Rapport ex√©cutif non disponible"

        # Affichage des r√©sultats
        print("\n" + "=" * 80)
        print("üá´üá∑ R√âSULTATS DE L'ANALYSE DE RECRUTEMENT FRAN√áAIS")
        print("=" * 80)

        # Analyse RFP
        print(f"\nüìÑ ANALYSE RFP (Qualit√© Gemini: {rfp_data.get('gemini_quality_score', 0)}/10)")
        print("-" * 55)
        print(f"Poste: {rfp_data['title']}")
        print(f"Entreprise: {rfp_data['company']}")
        print(f"Secteur: {rfp_data['sector']}")
        print(f"Localisation: {rfp_data['location']}")
        print(f"Niveau: {rfp_data.get('gemini_difficulty_level', 'Non d√©fini')}")
        print(f"Type de r√¥le: {rfp_data.get('gemini_role_type', 'Non d√©fini')}")
        print(f"Exp√©rience requise: {rfp_data['experience_years_min']} ans")
        print(f"Comp√©tences cl√©s: {', '.join(rfp_data['mandatory_skills'][:6])}")

        if rfp_data.get('gemini_additional_skills'):
            print(f"Comp√©tences sugg√©r√©es par Gemini: {', '.join(rfp_data['gemini_additional_skills'][:3])}")

        # Top candidats
        print(f"\nüèÜ TOP CANDIDATS (Analyse Gemini Fran√ßaise)")
        print("-" * 50)

        for i, candidate in enumerate(top_candidates[:8], 1):
            print(f"\n{i}. Candidat #{candidate['id']} ({candidate['category']})")
            print(f"   Score de match: {candidate['match_score']:.1%}")
            print(f"   Exp√©rience: {candidate['experience_years']} ans")
            print(f"   Contrat recommand√©: {candidate['recommended_contract']}")
            print(f"   Co√ªt estim√©: {candidate['estimated_cost']:,} ‚Ç¨/an")

            # Analyse Gemini si disponible
            if 'gemini_recommendation' in candidate:
                print(f"   Recommandation Gemini: {candidate['gemini_recommendation']}")
                print(f"   Ad√©quation technique: {candidate.get('gemini_technical_fit', 'N/A')}/10")
                print(f"   Pertinence exp√©rience: {candidate.get('gemini_experience_relevance', 'N/A')}/10")

                if candidate.get('gemini_strengths'):
                    print(f"   Forces: {', '.join(candidate['gemini_strengths'][:2])}")

                if candidate.get('gemini_concerns'):
                    print(f"   Points d'attention: {', '.join(candidate['gemini_concerns'][:2])}")

                if candidate.get('gemini_contract_suggestion'):
                    print(f"   Contrat sugg√©r√© Gemini: {candidate['gemini_contract_suggestion']}")

        # Analyse du march√©
        print(f"\nüìä ANALYSE DU MARCH√â FRAN√áAIS")
        print("-" * 35)
        print(f"Total analys√©: {market_data['total_candidates_analyzed']} candidats")
        print(f"Score moyen: {market_data['average_match_score']:.1%}")

        print(f"\nDistribution par exp√©rience:")
        exp_dist = market_data['experience_distribution']
        print(f"  Junior (0-2 ans): {exp_dist['junior_0_2_ans']}")
        print(f"  Confirm√© (3-5 ans): {exp_dist['confirme_3_5_ans']}")
        print(f"  Senior (6-10 ans): {exp_dist['senior_6_10_ans']}")
        print(f"  Expert (10+ ans): {exp_dist['expert_10_plus_ans']}")

        print(f"\nDistribution des scores:")
        score_dist = market_data['score_distribution']
        print(f"  Excellent (80%+): {score_dist['excellent_80_plus']}")
        print(f"  Bon (60-79%): {score_dist['bon_60_79']}")
        print(f"  Correct (40-59%): {score_dist['correct_40_59']}")
        print(f"  Faible (<40%): {score_dist['faible_moins_40']}")

        print(f"\nCat√©gories principales:")
        for cat, count in list(market_data['top_categories'].items())[:5]:
            print(f"  {cat}: {count} candidats")

        # Rapport ex√©cutif Gemini
        print(f"\nü§ñ RAPPORT EX√âCUTIF GEMINI")
        print("-" * 35)
        print(final_report)

        # Recommandations
        print(f"\nüìã RECOMMANDATIONS STRAT√âGIQUES")
        print("-" * 40)

        best_score = top_candidates[0]['match_score'] if top_candidates else 0
        excellent_count = score_dist['excellent_80_plus']

        if best_score >= 0.8 and excellent_count >= 2:
            recommendation = "EMBAUCHE RECOMMAND√âE"
            print("‚úÖ Recommandation: PROC√âDER √Ä L'EMBAUCHE")
            print("   Plusieurs candidats excellents identifi√©s")
            print("   Processus d'entretien √† d√©marrer rapidement")
        elif best_score >= 0.6:
            recommendation = "√âVALUATION APPROFONDIE"
            print("üîç Recommandation: √âVALUATION APPROFONDIE")
            print("   Candidats prometteurs n√©cessitant une analyse d√©taill√©e")
            print("   Entretiens techniques recommand√©s")
        else:
            recommendation = "√âLARGIR LA RECHERCHE"
            print("üîÑ Recommandation: √âLARGIR LA RECHERCHE")
            print("   Pool actuel insuffisant")
            print("   R√©viser les crit√®res ou sources de recrutement")

        print(f"\nüí∞ ESTIMATION BUDG√âTAIRE")
        print("-" * 25)
        if top_candidates:
            costs = [c['estimated_cost'] for c in top_candidates[:5]]
            print(f"Fourchette co√ªt: {min(costs):,} ‚Ç¨ - {max(costs):,} ‚Ç¨ / an")
            print(f"Co√ªt moyen top 5: {int(np.mean(costs)):,} ‚Ç¨ / an")

        print(f"\n‚è±Ô∏è PLANNING ESTIM√â")
        print("-" * 20)
        if recommendation == "EMBAUCHE RECOMMAND√âE":
            print("  Phase entretiens: 2-3 semaines")
            print("  Int√©gration: 3-4 semaines")
            print("  Total: 5-7 semaines")
        elif recommendation == "√âVALUATION APPROFONDIE":
            print("  √âvaluation approfondie: 3-4 semaines")
            print("  Phase entretiens: 2-3 semaines")
            print("  Int√©gration: 3-4 semaines")
            print("  Total: 8-11 semaines")
        else:
            print("  Recherche compl√©mentaire: 4-8 semaines")
            print("  Process complet: 10-15 semaines")

        print("\n" + "=" * 80)
        print("‚úÖ ANALYSE DE RECRUTEMENT FRAN√áAIS TERMIN√âE!")
        print("üíæ Donn√©es disponibles dans les variables de retour")
        print("=" * 80)

        return {
            'rfp_data': rfp_data,
            'top_candidates': top_candidates,
            'all_candidates': analyzed_candidates,
            'market_data': market_data,
            'final_report': final_report,
            'recommendation': recommendation
        }

    except Exception as e:
        print(f"‚ùå Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

class AnalyseurCandidatsFrancais:
    """Analyseur de candidats optimis√© pour le contexte fran√ßais"""

    def __init__(self, agent_gemini: AgentGeminiFrancais):
        self.gemini = agent_gemini

        # Variantes fran√ßaises pour matching
        self.variantes_francaises = {
            'python': ['python', 'py'],
            'javascript': ['javascript', 'js', 'node'],
            'machine learning': ['machine learning', 'ml', 'apprentissage automatique'],
            'data science': ['data science', 'science des donn√©es'],
            'gestion de projet': ['gestion de projet', 'chef de projet', 'project management'],
            'd√©veloppement web': ['d√©veloppement web', 'dev web', 'web development'],
            'rgpd': ['rgpd', 'gdpr', 'protection des donn√©es'],
            'cybers√©curit√©': ['cybers√©curit√©', 's√©curit√© informatique', 'cyber s√©curit√©']
        }

        # Tarifs fran√ßais (base annuelle en EUR)
        self.tarifs_francais = {
            'CDI': 42000,
            'CDD': 45000,
            'Expert': 75000,
            'Freelance': 58000,
            'Stage': 12000,
            'Alternance': 18000
        }

    def analyser_candidat(self, candidat_data: dict, rfp: RFPFrancais) -> ProfilCandidat:
        """Analyse compl√®te d'un candidat"""

        texte_cv = candidat_data.get('resume_text', '').lower()

        # Extraction comp√©tences avec matching fran√ßais
        competences_trouvees = self._extraire_competences_candidat(texte_cv, rfp.competences_obligatoires + rfp.competences_souhaitees)

        # Extraction certifications
        certifications = self._extraire_certifications_candidat(texte_cv, rfp.certifications_requises)

        # Extraction exp√©rience
        experience_ans = self._extraire_experience_candidat(texte_cv)

        # Calcul scores
        competences_obligatoires_trouvees = [c for c in competences_trouvees if c in rfp.competences_obligatoires]
        couverture_obligatoire = len(competences_obligatoires_trouvees) / max(len(rfp.competences_obligatoires), 1)

        competences_souhaitees_trouvees = [c for c in competences_trouvees if c in rfp.competences_souhaitees]
        couverture_souhaitee = len(competences_souhaitees_trouvees) / max(len(rfp.competences_souhaitees), 1)

        match_certifications = any(cert in rfp.certifications_requises for cert in certifications)
        match_experience = experience_ans >= rfp.experience_min_ans

        # Bonus contexte fran√ßais
        bonus_francais = 0.1 if any(mot in texte_cv for mot in ['france', 'fran√ßais', 'rgpd', 'cnil']) else 0

        # Score global
        score_match = min(
            couverture_obligatoire * 0.5 +
            (1.0 if match_experience else max(0.3, experience_ans / max(rfp.experience_min_ans, 1) * 0.7)) * 0.3 +
            couverture_souhaitee * 0.1 +
            (0.1 if match_certifications else 0) +
            bonus_francais,
            1.0
        )

        # Recommandation contrat et co√ªt
        contrat, cout = self._recommander_contrat_cout(score_match, experience_ans, rfp.types_contrat)

        # Analyse forces/lacunes
        forces, lacunes = self._analyser_forces_lacunes(
            competences_obligatoires_trouvees, competences_souhaitees_trouvees,
            certifications, experience_ans, rfp.experience_min_ans
        )

        # √âvaluation risque
        niveau_risque = self._evaluer_risque(score_match, couverture_obligatoire, match_certifications, match_experience)

        return ProfilCandidat(
            id=candidat_data.get('id', 0),
            categorie=candidat_data.get('category', 'Inconnu'),
            texte_cv=candidat_data.get('resume_text', ''),
            competences_trouvees=competences_trouvees,
            certifications=certifications,
            experience_ans=experience_ans,
            score_match=score_match,
            couverture_obligatoire=couverture_obligatoire,
            couverture_souhaitee=couverture_souhaitee,
            match_certifications=match_certifications,
            match_experience=match_experience,
            contrat_recommande=contrat,
            cout_estime=cout,
            forces=forces,
            lacunes=lacunes,
            niveau_risque=niveau_risque,
            axes_entretien=[]
        )

    def ameliorer_avec_gemini(self, candidat: ProfilCandidat, rfp: RFPFrancais) -> ProfilCandidat:
        """Am√©liore l'analyse avec Gemini"""

        try:
            # Pr√©parer donn√©es pour Gemini
            donnees_candidat = {
                'categorie': candidat.categorie,
                'experience_ans': candidat.experience_ans,
                'competences_trouvees': candidat.competences_trouvees,
                'score_match': candidat.score_match,
                'texte_cv': candidat.texte_cv
            }

            donnees_rfp = {
                'titre': rfp.titre,
                'competences_obligatoires': rfp.competences_obligatoires,
                'experience_min_ans': rfp.experience_min_ans,
                'secteur': rfp.secteur
            }

            # Analyse Gemini
            analyse_gemini = self.gemini.analyser_candidat_francais(donnees_candidat, donnees_rfp)

            # Mise √† jour du profil
            candidat.adequation_technique = analyse_gemini['adequation_technique']
            candidat.pertinence_experience = analyse_gemini['pertinence_experience']
            candidat.recommandation_gemini = analyse_gemini['recommandation']
            candidat.axes_entretien = analyse_gemini['axes_entretien']
            candidat.besoins_integration = analyse_gemini['besoins_integration']

            # Mise √† jour forces/lacunes avec Gemini
            if analyse_gemini['forces']:
                candidat.forces = analyse_gemini['forces']
            if analyse_gemini['points_attention']:
                candidat.lacunes = analyse_gemini['points_attention']

        except Exception as e:
            print(f"Attention: Am√©lioration Gemini √©chou√©e: {e}")

        return candidat

    def _extraire_competences_candidat(self, texte_cv: str, competences_recherchees: List[str]) -> List[str]:
        """Extrait les comp√©tences avec matching fran√ßais"""
        competences_trouvees = []

        for competence in competences_recherchees:
            if self._matcher_competence_francaise(competence.lower(), texte_cv):
                competences_trouvees.append(competence)

        return competences_trouvees

    def _matcher_competence_francaise(self, competence: str, texte_cv: str) -> bool:
        """Matching de comp√©tence avec variantes fran√ßaises"""

        # Match direct
        if competence in texte_cv:
            return True

        # Variantes fran√ßaises
        variantes = self.variantes_francaises.get(competence, [competence])
        return any(variante in texte_cv for variante in variantes)

    def _extraire_certifications_candidat(self, texte_cv: str, certifications_recherchees: List[str]) -> List[str]:
        """Extrait les certifications"""
        certifications_trouvees = []

        for cert in certifications_recherchees:
            if cert.lower() in texte_cv:
                certifications_trouvees.append(cert)

        return certifications_trouvees

    def _extraire_experience_candidat(self, texte_cv: str) -> int:
        """Extrait l'exp√©rience avec patterns fran√ßais"""
        patterns = [
            r'(\d+)\s*(?:ans?|ann√©es?)\s*(?:d[\'e]\s*)?(?:exp√©riences?)',
            r'(\d+)\+\s*(?:ans?|ann√©es?)',
            r'depuis\s*(\d+)\s*(?:ans?|ann√©es?)'
        ]

        annees = []
        for pattern in patterns:
            matches = re.findall(pattern, texte_cv)
            annees.extend([int(m) for m in matches if m.isdigit()])

        return max(annees) if annees else 0

    def _recommander_contrat_cout(self, score_match: float, experience: int, contrats_disponibles: List[str]) -> Tuple[str, int]:
        """Recommande contrat et co√ªt fran√ßais"""

        # Multiplicateurs
        mult_experience = 1 + (experience * 0.045)  # 4.5% par an
        mult_match = 0.8 + (score_match * 0.4)     # 80-120%

        # Choix contrat
        if score_match >= 0.8 and experience >= 5 and 'Expert' in contrats_disponibles:
            type_contrat = 'Expert'
        elif score_match >= 0.7 and 'CDI' in contrats_disponibles:
            type_contrat = 'CDI'
        elif score_match >= 0.5 and 'CDD' in contrats_disponibles:
            type_contrat = 'CDD'
        elif 'Freelance' in contrats_disponibles:
            type_contrat = 'Freelance'
        else:
            type_contrat = contrats_disponibles[0] if contrats_disponibles else 'CDI'

        # Calcul co√ªt
        cout_base = self.tarifs_francais.get(type_contrat, 42000)
        cout_estime = int(cout_base * mult_experience * mult_match)

        return type_contrat, cout_estime

    def _analyser_forces_lacunes(self, comp_obligatoires: List[str], comp_souhaitees: List[str],
                                certifications: List[str], experience: int, exp_requise: int) -> Tuple[List[str], List[str]]:
        """Analyse forces et lacunes"""

        forces = []
        lacunes = []

        # Forces
        if len(comp_obligatoires) > 0:
            forces.append(f"Ma√Ætrise de {len(comp_obligatoires)} comp√©tences cl√©s")

        if certifications:
            forces.append(f"Certifications pertinentes: {', '.join(certifications[:2])}")

        if experience >= exp_requise:
            forces.append(f"Exp√©rience suffisante ({experience} ans)")

        if len(comp_souhaitees) > 0:
            forces.append(f"Comp√©tences bonus: {', '.join(comp_souhaitees[:2])}")

        # Lacunes
        if len(comp_obligatoires) == 0:
            lacunes.append("Aucune comp√©tence obligatoire identifi√©e")

        if not certifications:
            lacunes.append("Pas de certifications trouv√©es")

        if experience < exp_requise:
            lacunes.append(f"Exp√©rience insuffisante ({experience}/{exp_requise} ans)")

        return forces[:3], lacunes[:3]

    def _evaluer_risque(self, score_match: float, couverture_obligatoire: float,
                       match_certif: bool, match_exp: bool) -> str:
        """√âvalue le niveau de risque"""

        facteurs_risque = 0

        if score_match < 0.5:
            facteurs_risque += 2
        elif score_match < 0.7:
            facteurs_risque += 1

        if couverture_obligatoire < 0.5:
            facteurs_risque += 2

        if not match_certif:
            facteurs_risque += 1

        if not match_exp:
            facteurs_risque += 1

        if facteurs_risque == 0:
            return "Faible"
        elif facteurs_risque <= 2:
            return "Moyen"
        elif facteurs_risque <= 4:
            return "√âlev√©"
        else:
            return "Tr√®s √©lev√©"

print("‚úÖ Analyseur Candidats Fran√ßais pr√™t")

class SystemeRecrutementFrancais:
    """Syst√®me complet de recrutement fran√ßais avec Gemini"""

    def __init__(self, modele_gemini: str = "google/gemma-2b-it"):
        print("üöÄ Initialisation du Syst√®me de Recrutement Fran√ßais")
        print("=" * 55)

        self.parseur_rfp = ParseurRFPFrancais()
        self.agent_gemini = AgentGeminiFrancais(modele_gemini)
        self.analyseur_candidats = AnalyseurCandidatsFrancais(self.agent_gemini)

        print("‚úÖ Syst√®me initialis√© avec succ√®s")

    def analyser_recrutement_complet(self, chemin_pdf: str, chemin_csv: str) -> Dict:
        """Analyse compl√®te de recrutement fran√ßais"""

        resultats = {
            'rfp': None,
            'candidats_top': [],
            'tous_candidats': [],
            'donnees_marche': {},
            'rapport_executif': "",
            'recommandation': "",
            'timeline': "",
            'budget': (0, 0)
        }

        try:
            # 1. Analyse RFP
            print("\nüìÑ ANALYSE DU RFP FRAN√áAIS")
            print("-" * 35)

            rfp = self.parseur_rfp.analyser_rfp_complet(chemin_pdf)
            print(f"‚úÖ RFP analys√© - Confiance: {rfp.score_confiance:.1%}")
            print(f"   Titre: {rfp.titre}")
            print(f"   Entreprise: {rfp.entreprise}")
            print(f"   Secteur: {rfp.secteur}")
            print(f"   Comp√©tences trouv√©es: {len(rfp.competences_obligatoires)}")

            # Am√©lioration Gemini du RFP
            try:
                donnees_rfp = {
                    'titre': rfp.titre,
                    'competences_obligatoires': rfp.competences_obligatoires,
                    'competences_souhaitees': rfp.competences_souhaitees,
                    'experience_min_ans': rfp.experience_min_ans,
                    'certifications_requises': rfp.certifications_requises
                }

                analyse_gemini_rfp = self.agent_gemini.analyser_rfp_francais(rfp.texte_brut, donnees_rfp)

                rfp.niveau_poste = analyse_gemini_rfp['niveau_poste']
                rfp.type_role = analyse_gemini_rfp['type_role']

                # Ajout comp√©tences sugg√©r√©es par Gemini
                if analyse_gemini_rfp['competences_supplementaires']:
                    rfp.competences_obligatoires.extend(analyse_gemini_rfp['competences_supplementaires'][:3])
                    rfp.competences_obligatoires = list(set(rfp.competences_obligatoires))

                print(f"ü§ñ Am√©lioration Gemini - Niveau: {rfp.niveau_poste}, Type: {rfp.type_role}")

            except Exception as e:
                print(f"   Attention: Am√©lioration Gemini RFP √©chou√©e: {e}")

            resultats['rfp'] = rfp

            # 2. Chargement candidats
            print(f"\nüìä CHARGEMENT DES CANDIDATS")
            print("-" * 30)

            df = pd.read_csv(chemin_csv)
            candidats_data = []

            for idx, row in df.iterrows():
                candidats_data.append({
                    'id': idx,
                    'category': row['Category'],
                    'resume_text': row['Resume']
                })

            print(f"‚úÖ {len(candidats_data)} candidats charg√©s")

            # 3. Analyse candidats
            print(f"\nüîç ANALYSE DES CANDIDATS")
            print("-" * 25)

            candidats_analyses = []

            for i, candidat_data in enumerate(candidats_data):
                if i % 50 == 0:
                    print(f"   Trait√© {i}/{len(candidats_data)} candidats...")

                # Analyse de base
                profil = self.analyseur_candidats.analyser_candidat(candidat_data, rfp)
                candidats_analyses.append(profil)

            print(f"‚úÖ Analyse de base termin√©e")

            # Tri par score
            candidats_analyses.sort(key=lambda x: x.score_match, reverse=True)

            # 4. Am√©lioration Gemini pour les top candidats
            print(f"\nü§ñ AM√âLIORATION GEMINI TOP CANDIDATS")
            print("-" * 35)

            candidats_prometteurs = [c for c in candidats_analyses if c.score_match >= 0.4][:20]

            for i, candidat in enumerate(candidats_prometteurs):
                print(f"   Gemini {i+1}/{len(candidats_prometteurs)}: Candidat #{candidat.id}")
                try:
                    candidat = self.analyseur_candidats.ameliorer_avec_gemini(candidat, rfp)
                except Exception as e:
                    print(f"     Attention: √âchec Gemini pour candidat {candidat.id}")

            print(f"‚úÖ Am√©lioration Gemini termin√©e")

            # Re-tri apr√®s Gemini
            candidats_analyses.sort(key=lambda x: x.score_match, reverse=True)
            candidats_top = candidats_analyses[:15]

            resultats['candidats_top'] = candidats_top
            resultats['tous_candidats'] = candidats_analyses

            # 5. G√©n√©ration donn√©es march√©
            donnees_marche = self._generer_donnees_marche(candidats_analyses)
            resultats['donnees_marche'] = donnees_marche

            # 6. G√©n√©ration rapport ex√©cutif
            print(f"\nüìã G√âN√âRATION RAPPORT EX√âCUTIF")
            print("-" * 30)


            rapport_executif = self.agent_gemini.generer_rapport_executif(
                    candidats_top, donnees_rfp, donnees_marche
                )

                # V√©rifier que le rapport n'est pas vide
            if not rapport_executif or len(rapport_executif.strip()) < 50:
                    print("‚ö†Ô∏è  Rapport Gemini minimal, g√©n√©ration d'un rapport de base")
                    rapport_executif = "didn't work"

            resultats['rapport_executif'] = rapport_executif
            print("‚úÖ Rapport ex√©cutif g√©n√©r√©")


            # 7. Recommandations finales
            meilleur_score = candidats_top[0].score_match if candidats_top else 0
            excellents = len([c for c in candidats_analyses if c.score_match >= 0.8])

            if meilleur_score >= 0.8 and excellents >= 2:
                resultats['recommandation'] = "EMBAUCHER"
                resultats['timeline'] = "2-4 semaines"
            elif meilleur_score >= 0.6:
                resultats['recommandation'] = "√âVALUER"
                resultats['timeline'] = "4-6 semaines"
            else:
                resultats['recommandation'] = "√âLARGIR RECHERCHE"
                resultats['timeline'] = "6-10 semaines"

            # Budget
            if candidats_top:
                couts = [c.cout_estime for c in candidats_top[:5]]
                resultats['budget'] = (min(couts), max(couts))

            return resultats

        except Exception as e:
            print(f"‚ùå Erreur lors de l'analyse: {e}")
            import traceback
            traceback.print_exc()
            return resultats

    def _generer_donnees_marche(self, candidats: List[ProfilCandidat]) -> Dict:
        """G√©n√®re les donn√©es d'analyse de march√©"""

        categories = [c.categorie for c in candidats]
        scores = [c.score_match for c in candidats]
        experiences = [c.experience_ans for c in candidats]

        return {
            'total_analyses': len(candidats),
            'score_moyen': np.mean(scores),
            'avec_certifications': len([c for c in candidats if c.match_certifications]),
            'categories_top': dict(Counter(categories).most_common(5)),
            'distribution_experience': {
                'junior_0_2': len([e for e in experiences if 0 <= e <= 2]),
                'confirme_3_5': len([e for e in experiences if 3 <= e <= 5]),
                'senior_6_10': len([e for e in experiences if 6 <= e <= 10]),
                'expert_10_plus': len([e for e in experiences if e > 10])
            },
            'distribution_scores': {
                'excellent_80_plus': len([s for s in scores if s >= 0.8]),
                'bon_60_79': len([s for s in scores if 0.6 <= s < 0.8]),
                'moyen_40_59': len([s for s in scores if 0.4 <= s < 0.6]),
                'faible_moins_40': len([s for s in scores if s < 0.4])
            }
        }

    def afficher_resultats(self, resultats: Dict):
        """Affiche les r√©sultats d'analyse"""

        if not resultats or not resultats['rfp']:
            print("‚ùå Aucun r√©sultat √† afficher")
            return

        rfp = resultats['rfp']
        candidats_top = resultats['candidats_top']
        donnees_marche = resultats['donnees_marche']

        print("\n" + "=" * 80)
        print("üá´üá∑ R√âSULTATS ANALYSE DE RECRUTEMENT FRAN√áAIS")
        print("=" * 80)

        # RFP
        print(f"\nüìÑ ANALYSE RFP")
        print("-" * 20)
        print(f"Poste: {rfp.titre}")
        print(f"Entreprise: {rfp.entreprise}")
        print(f"Secteur: {rfp.secteur}")
        print(f"Niveau: {rfp.niveau_poste}")
        print(f"Localisation: {rfp.localisation}")
        print(f"Exp√©rience requise: {rfp.experience_min_ans} ans")
        print(f"Comp√©tences cl√©s: {', '.join(rfp.competences_obligatoires[:6])}")

        # Top candidats
        print(f"\nüèÜ TOP CANDIDATS")
        print("-" * 15)

        for i, candidat in enumerate(candidats_top[:8], 1):
            print(f"\n{i}. Candidat #{candidat.id} ({candidat.categorie})")
            print(f"   Score: {candidat.score_match:.1%}")
            print(f"   Exp√©rience: {candidat.experience_ans} ans")
            print(f"   Contrat: {candidat.contrat_recommande}")
            print(f"   Co√ªt: {candidat.cout_estime:,} ‚Ç¨/an")
            print(f"   Risque: {candidat.niveau_risque}")

            if candidat.recommandation_gemini:
                print(f"   Gemini: {candidat.recommandation_gemini}")
                if candidat.adequation_technique > 0:
                    print(f"   Technique: {candidat.adequation_technique}/10")

            if candidat.forces:
                print(f"   Forces: {', '.join(candidat.forces[:2])}")

        # March√©
        print(f"\nüìä ANALYSE MARCH√â")
        print("-" * 15)
        print(f"Total analys√©: {donnees_marche['total_analyses']}")
        print(f"Score moyen: {donnees_marche['score_moyen']:.1%}")
        print(f"Avec certifications: {donnees_marche['avec_certifications']}")

        dist_scores = donnees_marche['distribution_scores']
        print(f"\nDistribution qualit√©:")
        print(f"  Excellent (80%+): {dist_scores['excellent_80_plus']}")
        print(f"  Bon (60-79%): {dist_scores['bon_60_79']}")
        print(f"  Moyen (40-59%): {dist_scores['moyen_40_59']}")
        print(f"  Faible (<40%): {dist_scores['faible_moins_40']}")

        # Recommandation
        print(f"\nüéØ RECOMMANDATION")
        print("-" * 15)
        print(f"Decision: {resultats['recommandation']}")
        print(f"Timeline: {resultats['timeline']}")
        if resultats['budget'][0] > 0:
            print(f"Budget: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} ‚Ç¨")

        # Rapport Gemini
        if resultats['rapport_executif']:
            print(f"\nü§ñ RAPPORT GEMINI")
            print("-" * 15)
            print(resultats['rapport_executif'])

        print("\n" + "=" * 80)

    def sauvegarder_resultats(self, resultats: Dict, dossier_sortie: str = "resultats_recrutement"):
        """Sauvegarde les r√©sultats avec g√©n√©ration PDF structur√©"""

        import os
        from datetime import datetime

        os.makedirs(dossier_sortie, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        try:
            # JSON principal (existant)
            donnees_principales = {
                'rfp': {
                    'titre': resultats['rfp'].titre,
                    'entreprise': resultats['rfp'].entreprise,
                    'secteur': resultats['rfp'].secteur,
                    'competences_obligatoires': resultats['rfp'].competences_obligatoires,
                    'experience_min_ans': resultats['rfp'].experience_min_ans,
                    'niveau_poste': resultats['rfp'].niveau_poste
                },
                'top_candidats': [
                    {
                        'id': c.id,
                        'categorie': c.categorie,
                        'score_match': c.score_match,
                        'experience_ans': c.experience_ans,
                        'contrat_recommande': c.contrat_recommande,
                        'cout_estime': c.cout_estime,
                        'niveau_risque': c.niveau_risque,
                        'recommandation_gemini': c.recommandation_gemini,
                        'adequation_technique': c.adequation_technique,
                        'pertinence_experience': c.pertinence_experience,
                        'forces': c.forces,
                        'lacunes': c.lacunes,
                        'axes_entretien': c.axes_entretien or [],
                        'besoins_integration': c.besoins_integration or []
                    } for c in resultats['candidats_top'][:10]
                ],
                'donnees_marche': resultats['donnees_marche'],
                'recommandation': resultats['recommandation'],
                'timeline': resultats['timeline'],
                'budget': resultats['budget'],
                'rapport_gemini': resultats['rapport_executif'],  # S'assurer que le rapport Gemini est inclus
                'timestamp': timestamp
            }

            with open(f"{dossier_sortie}/analyse_recrutement_{timestamp}.json", 'w', encoding='utf-8') as f:
                json.dump(donnees_principales, f, indent=2, ensure_ascii=False, default=str)

            # NOUVEAU: G√©n√©ration PDF structur√©
            pdf_file = self._generer_pdf_structure(resultats, dossier_sortie, timestamp)

            # Rapport ex√©cutif TXT (existant)
            with open(f"{dossier_sortie}/rapport_executif_{timestamp}.txt", 'w', encoding='utf-8') as f:
                f.write("RAPPORT EX√âCUTIF - ANALYSE DE RECRUTEMENT\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"G√©n√©r√© le: {datetime.now().strftime('%d/%m/%Y √† %H:%M')}\n\n")
                f.write(f"POSTE: {resultats['rfp'].titre}\n")
                f.write(f"ENTREPRISE: {resultats['rfp'].entreprise}\n\n")
                f.write("RAPPORT GEMINI:\n")
                f.write("-" * 20 + "\n")
                f.write(resultats['rapport_executif'])

            # Analyse compl√®te TXT (existant - gard√© pour compatibilit√©)
            with open(f"{dossier_sortie}/analyse_complete_{timestamp}.txt", 'w', encoding='utf-8') as f:
                f.write("üá´üá∑ ANALYSE COMPL√àTE DE RECRUTEMENT FRAN√áAIS\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"üìÖ G√©n√©r√© le: {datetime.now().strftime('%d/%m/%Y √† %H:%M:%S')}\n\n")

                # Section RFP
                f.write("üìÑ ANALYSE DU RFP\n")
                f.write("-" * 25 + "\n")
                f.write(f"Titre du poste: {resultats['rfp'].titre}\n")
                f.write(f"Entreprise: {resultats['rfp'].entreprise}\n")
                f.write(f"Secteur d'activit√©: {resultats['rfp'].secteur}\n")
                f.write(f"Niveau du poste: {resultats['rfp'].niveau_poste}\n")
                f.write(f"Type de r√¥le: {resultats['rfp'].type_role}\n")
                f.write(f"Localisation: {resultats['rfp'].localisation}\n")
                f.write(f"Exp√©rience requise: {resultats['rfp'].experience_min_ans} ans minimum\n")
                f.write(f"D√©lais: {resultats['rfp'].delais}\n")
                f.write(f"Budget: {resultats['rfp'].budget}\n")
                f.write(f"Score de confiance extraction: {resultats['rfp'].score_confiance:.1%}\n\n")

                f.write(f"Comp√©tences obligatoires ({len(resultats['rfp'].competences_obligatoires)}):\n")
                for i, comp in enumerate(resultats['rfp'].competences_obligatoires, 1):
                    f.write(f"  {i:2d}. {comp}\n")
                f.write("\n")

                f.write(f"Comp√©tences souhait√©es ({len(resultats['rfp'].competences_souhaitees)}):\n")
                for i, comp in enumerate(resultats['rfp'].competences_souhaitees, 1):
                    f.write(f"  {i:2d}. {comp}\n")
                f.write("\n")

                if resultats['rfp'].certifications_requises:
                    f.write(f"Certifications requises:\n")
                    for i, cert in enumerate(resultats['rfp'].certifications_requises, 1):
                        f.write(f"  {i}. {cert}\n")
                    f.write("\n")

                # Section Candidats Top
                f.write("üèÜ TOP CANDIDATS ANALYS√âS\n")
                f.write("-" * 30 + "\n")

                for i, candidat in enumerate(resultats['candidats_top'][:10], 1):
                    f.write(f"{i:2d}. CANDIDAT #{candidat.id:3d} | {candidat.categorie}\n")
                    f.write(f"    Score de correspondance: {candidat.score_match:.1%}\n")
                    f.write(f"    Exp√©rience: {candidat.experience_ans} ans\n")
                    f.write(f"    Couverture comp√©tences obligatoires: {candidat.couverture_obligatoire:.1%}\n")
                    f.write(f"    Couverture comp√©tences souhait√©es: {candidat.couverture_souhaitee:.1%}\n")
                    f.write(f"    Certifications: {'‚úì' if candidat.match_certifications else '‚úó'}\n")
                    f.write(f"    Exp√©rience suffisante: {'‚úì' if candidat.match_experience else '‚úó'}\n")
                    f.write(f"    Contrat recommand√©: {candidat.contrat_recommande}\n")
                    f.write(f"    Co√ªt estim√©: {candidat.cout_estime:,} ‚Ç¨/an\n")
                    f.write(f"    Niveau de risque: {candidat.niveau_risque}\n")

                    if candidat.recommandation_gemini:
                        f.write(f"    Recommandation Gemini: {candidat.recommandation_gemini}\n")
                        if candidat.adequation_technique > 0:
                            f.write(f"    Ad√©quation technique: {candidat.adequation_technique}/10\n")
                        if candidat.pertinence_experience > 0:
                            f.write(f"    Pertinence exp√©rience: {candidat.pertinence_experience}/10\n")

                    if candidat.forces:
                        f.write(f"    Forces principales:\n")
                        for force in candidat.forces:
                            f.write(f"      ‚Ä¢ {force}\n")

                    if candidat.lacunes:
                        f.write(f"    Points d'attention:\n")
                        for lacune in candidat.lacunes:
                            f.write(f"      ‚Ä¢ {lacune}\n")

                    if candidat.axes_entretien:
                        f.write(f"    Axes d'entretien sugg√©r√©s:\n")
                        for axe in candidat.axes_entretien:
                            f.write(f"      ‚Ä¢ {axe}\n")

                    if candidat.besoins_integration:
                        f.write(f"    Besoins d'int√©gration:\n")
                        for besoin in candidat.besoins_integration:
                            f.write(f"      ‚Ä¢ {besoin}\n")

                    f.write(f"    Comp√©tences trouv√©es: {', '.join(candidat.competences_trouvees[:8])}")
                    if len(candidat.competences_trouvees) > 8:
                        f.write(f" (+{len(candidat.competences_trouvees)-8} autres)")
                    f.write("\n\n")

                # Section Analyse March√©
                f.write("üìä ANALYSE DU MARCH√â\n")
                f.write("-" * 25 + "\n")
                dm = resultats['donnees_marche']
                f.write(f"Total candidats analys√©s: {dm['total_analyses']}\n")
                f.write(f"Score moyen de correspondance: {dm['score_moyen']:.1%}\n")
                f.write(f"Candidats avec certifications: {dm['avec_certifications']}\n\n")

                f.write("Distribution par niveau d'exp√©rience:\n")
                exp_dist = dm['distribution_experience']
                f.write(f"  ‚Ä¢ Junior (0-2 ans): {exp_dist['junior_0_2']} candidats\n")
                f.write(f"  ‚Ä¢ Confirm√© (3-5 ans): {exp_dist['confirme_3_5']} candidats\n")
                f.write(f"  ‚Ä¢ Senior (6-10 ans): {exp_dist['senior_6_10']} candidats\n")
                f.write(f"  ‚Ä¢ Expert (10+ ans): {exp_dist['expert_10_plus']} candidats\n\n")

                f.write("Distribution par qualit√© de correspondance:\n")
                score_dist = dm['distribution_scores']
                f.write(f"  ‚Ä¢ Excellent (80%+): {score_dist['excellent_80_plus']} candidats\n")
                f.write(f"  ‚Ä¢ Bon (60-79%): {score_dist['bon_60_79']} candidats\n")
                f.write(f"  ‚Ä¢ Moyen (40-59%): {score_dist['moyen_40_59']} candidats\n")
                f.write(f"  ‚Ä¢ Faible (<40%): {score_dist['faible_moins_40']} candidats\n\n")

                f.write("Top 5 cat√©gories de candidats:\n")
                for i, (categorie, nombre) in enumerate(dm['categories_top'].items(), 1):
                    if i <= 5:
                        f.write(f"  {i}. {categorie}: {nombre} candidats\n")
                f.write("\n")

                # Section Recommandations
                f.write("üéØ RECOMMANDATIONS STRAT√âGIQUES\n")
                f.write("-" * 35 + "\n")
                f.write(f"D√©cision recommand√©e: {resultats['recommandation']}\n")
                f.write(f"Timeline estim√©e: {resultats['timeline']}\n")
                if resultats['budget'][0] > 0:
                    f.write(f"Fourchette budg√©taire: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} ‚Ç¨ / an\n")
                f.write("\n")

                # Justification de la recommandation
                if resultats['recommandation'] == "EMBAUCHER":
                    f.write("Justification: Plusieurs candidats excellents identifi√©s avec un fort potentiel.\n")
                    f.write("Actions recommand√©es:\n")
                    f.write("  ‚Ä¢ Planifier les entretiens avec les 3 meilleurs candidats\n")
                    f.write("  ‚Ä¢ Pr√©parer les √©valuations techniques sp√©cifiques\n")
                    f.write("  ‚Ä¢ V√©rifier les r√©f√©rences et certifications\n")
                    f.write("  ‚Ä¢ N√©gocier les conditions contractuelles\n")
                elif resultats['recommandation'] == "√âVALUER":
                    f.write("Justification: Candidats prometteurs n√©cessitant une √©valuation approfondie.\n")
                    f.write("Actions recommand√©es:\n")
                    f.write("  ‚Ä¢ Conduire des entretiens techniques d√©taill√©s\n")
                    f.write("  ‚Ä¢ √âvaluer les besoins de formation\n")
                    f.write("  ‚Ä¢ Consid√©rer une p√©riode d'essai\n")
                    f.write("  ‚Ä¢ √âlargir la recherche si n√©cessaire\n")
                else:
                    f.write("Justification: Pool actuel insuffisant pour les exigences du poste.\n")
                    f.write("Actions recommand√©es:\n")
                    f.write("  ‚Ä¢ R√©viser les crit√®res de s√©lection\n")
                    f.write("  ‚Ä¢ √âlargir les sources de recrutement\n")
                    f.write("  ‚Ä¢ Consid√©rer des cabinets sp√©cialis√©s\n")
                    f.write("  ‚Ä¢ √âvaluer les options de formation interne\n")
                f.write("\n")

                # Section Rapport Gemini
                f.write("ü§ñ RAPPORT EX√âCUTIF GEMINI\n")
                f.write("-" * 30 + "\n")
                f.write(resultats['rapport_executif'])
                f.write("\n\n")

                # Footer
                f.write("=" * 60 + "\n")
                f.write("Rapport g√©n√©r√© par le Syst√®me de Recrutement Fran√ßais avec Gemini\n")
                f.write(f"Fichier: analyse_complete_{timestamp}.txt\n")
                f.write("=" * 60 + "\n")

            # CSV candidats
            candidats_df = pd.DataFrame([
                {
                    'ID': c.id,
                    'Cat√©gorie': c.categorie,
                    'Score_Match': f"{c.score_match:.1%}",
                    'Exp√©rience_Ans': c.experience_ans,
                    'Contrat_Recommand√©': c.contrat_recommande,
                    'Co√ªt_Estim√©_EUR': c.cout_estime,
                    'Niveau_Risque': c.niveau_risque,
                    'Recommandation_Gemini': c.recommandation_gemini,
                    'Ad√©quation_Technique': f"{c.adequation_technique}/10" if c.adequation_technique > 0 else "N/A",
                    'Pertinence_Exp√©rience': f"{c.pertinence_experience}/10" if c.pertinence_experience > 0 else "N/A",
                    'Forces': '; '.join(c.forces),
                    'Lacunes': '; '.join(c.lacunes),
                    'Axes_Entretien': '; '.join(c.axes_entretien or []),
                    'Besoins_Int√©gration': '; '.join(c.besoins_integration or [])
                } for c in resultats['candidats_top'][:20]
            ])

            candidats_df.to_csv(f"{dossier_sortie}/candidats_top_{timestamp}.csv",
                              index=False, encoding='utf-8')

            print(f"‚úÖ R√©sultats sauvegard√©s dans: {dossier_sortie}/")
            print(f"   üìÑ Analyse compl√®te: analyse_recrutement_{timestamp}.json")
            print(f"   üìã Rapport ex√©cutif: rapport_executif_{timestamp}.txt")
            print(f"   üìä Top candidats: candidats_top_{timestamp}.csv")
            print(f"   üìù Analyse d√©taill√©e: analyse_complete_{timestamp}.txt")
            if pdf_file:
                print(f"   üìë Rapport PDF structur√©: {pdf_file}")

            return f"{dossier_sortie}/analyse_recrutement_{timestamp}.json"

        except Exception as e:
            print(f"‚ùå Erreur sauvegarde: {e}")
            return None

    def _generer_pdf_structure(self, resultats: Dict, dossier_sortie: str, timestamp: str) -> str:
        """G√©n√®re un PDF structur√© professionnel avec les r√©sultats LLM"""

        try:
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY
            from datetime import datetime

            # Nom du fichier PDF
            pdf_filename = f"{dossier_sortie}/rapport_recrutement_{timestamp}.pdf"

            # Cr√©ation du document
            doc = SimpleDocTemplate(pdf_filename, pagesize=A4,
                                  rightMargin=72, leftMargin=72,
                                  topMargin=72, bottomMargin=18)

            # Styles
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=18,
                textColor=colors.HexColor('#2E4057'),
                alignment=TA_CENTER,
                spaceAfter=30
            )

            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontSize=14,
                textColor=colors.HexColor('#048A81'),
                spaceBefore=20,
                spaceAfter=10
            )

            subheading_style = ParagraphStyle(
                'CustomSubHeading',
                parent=styles['Heading3'],
                fontSize=12,
                textColor=colors.HexColor('#2E4057'),
                spaceBefore=15,
                spaceAfter=8
            )

            normal_style = ParagraphStyle(
                'CustomNormal',
                parent=styles['Normal'],
                fontSize=10,
                alignment=TA_JUSTIFY,
                spaceAfter=6
            )

            # Contenu du PDF
            story = []

            # Page de titre
            story.append(Paragraph("RAPPORT D'ANALYSE DE RECRUTEMENT", title_style))
            story.append(Paragraph("Syst√®me de Recrutement Fran√ßais avec IA", styles['Heading3']))
            story.append(Spacer(1, 30))

            # Informations g√©n√©rales
            story.append(Paragraph(f"<b>Poste analys√©:</b> {resultats['rfp'].titre}", normal_style))
            story.append(Paragraph(f"<b>Entreprise:</b> {resultats['rfp'].entreprise}", normal_style))
            story.append(Paragraph(f"<b>Secteur:</b> {resultats['rfp'].secteur}", normal_style))
            story.append(Paragraph(f"<b>Date d'analyse:</b> {datetime.now().strftime('%d/%m/%Y √† %H:%M')}", normal_style))
            story.append(Spacer(1, 30))

            # R√©sum√© ex√©cutif
            story.append(Paragraph("R√âSUM√â EX√âCUTIF", heading_style))

            # Bo√Æte de recommandation
            recommandation_color = colors.green if resultats['recommandation'] == "EMBAUCHER" else \
                                  colors.orange if resultats['recommandation'] == "√âVALUER" else colors.red

            rec_data = [
                ['RECOMMANDATION', resultats['recommandation']],
                ['TIMELINE', resultats['timeline']],
                ['BUDGET ESTIM√â', f"{resultats['budget'][0]:,} - {resultats['budget'][1]:,} ‚Ç¨/an" if resultats['budget'][0] > 0 else "√Ä d√©finir"],
                ['CANDIDATS ANALYS√âS', str(resultats['donnees_marche']['total_analyses'])],
                ['CANDIDATS EXCELLENTS', str(resultats['donnees_marche']['distribution_scores']['excellent_80_plus'])]
            ]

            rec_table = Table(rec_data, colWidths=[2*inch, 3*inch])
            rec_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#048A81')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('BACKGROUND', (0, 1), (0, -1), colors.HexColor('#E8F4F8')),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(rec_table)
            story.append(Spacer(1, 20))

            # Analyse du RFP
            story.append(Paragraph("ANALYSE DU POSTE", heading_style))
            story.append(Paragraph(f"<b>Niveau requis:</b> {resultats['rfp'].niveau_poste}", normal_style))
            story.append(Paragraph(f"<b>Exp√©rience minimum:</b> {resultats['rfp'].experience_min_ans} ans", normal_style))
            story.append(Paragraph(f"<b>Localisation:</b> {resultats['rfp'].localisation}", normal_style))

            # Comp√©tences obligatoires
            story.append(Paragraph("Comp√©tences obligatoires:", subheading_style))
            comp_text = ", ".join(resultats['rfp'].competences_obligatoires[:10])
            if len(resultats['rfp'].competences_obligatoires) > 10:
                comp_text += f" (et {len(resultats['rfp'].competences_obligatoires) - 10} autres)"
            story.append(Paragraph(comp_text, normal_style))
            story.append(Spacer(1, 15))

            # TOP CANDIDATS
            story.append(Paragraph("TOP CANDIDATS IDENTIFI√âS", heading_style))

            if resultats['candidats_top']:
                for i, candidat in enumerate(resultats['candidats_top'][:5], 1):
                    story.append(Paragraph(f"CANDIDAT #{candidat.id} - {candidat.categorie}", subheading_style))

                    # Tableau des m√©triques du candidat
                    candidat_data = [
                        ['Score de correspondance', f"{candidat.score_match:.1%}"],
                        ['Exp√©rience', f"{candidat.experience_ans} ans"],
                        ['Contrat recommand√©', candidat.contrat_recommande],
                        ['Co√ªt estim√©', f"{candidat.cout_estime:,} ‚Ç¨/an"],
                        ['Niveau de risque', candidat.niveau_risque]
                    ]

                    # Ajouter les scores Gemini si disponibles
                    if candidat.adequation_technique > 0:
                        candidat_data.append(['Ad√©quation technique (Gemini)', f"{candidat.adequation_technique}/10"])
                    if candidat.pertinence_experience > 0:
                        candidat_data.append(['Pertinence exp√©rience (Gemini)', f"{candidat.pertinence_experience}/10"])
                    if candidat.recommandation_gemini:
                        candidat_data.append(['Recommandation Gemini', candidat.recommandation_gemini])

                    candidat_table = Table(candidat_data, colWidths=[2.5*inch, 2.5*inch])
                    candidat_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F0F8FF')),
                        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)
                    ]))
                    story.append(candidat_table)

                    # Forces et lacunes
                    if candidat.forces:
                        story.append(Paragraph("<b>Forces:</b>", normal_style))
                        for force in candidat.forces[:3]:
                            story.append(Paragraph(f"‚Ä¢ {force}", normal_style))

                    if candidat.lacunes:
                        story.append(Paragraph("<b>Points d'attention:</b>", normal_style))
                        for lacune in candidat.lacunes[:3]:
                            story.append(Paragraph(f"‚Ä¢ {lacune}", normal_style))

                    # Axes d'entretien Gemini
                    if candidat.axes_entretien:
                        story.append(Paragraph("<b>Axes d'entretien sugg√©r√©s (Gemini):</b>", normal_style))
                        for axe in candidat.axes_entretien[:3]:
                            story.append(Paragraph(f"‚Ä¢ {axe}", normal_style))

                    # Besoins d'int√©gration Gemini
                    if candidat.besoins_integration:
                        story.append(Paragraph("<b>Besoins d'int√©gration (Gemini):</b>", normal_style))
                        for besoin in candidat.besoins_integration[:3]:
                            story.append(Paragraph(f"‚Ä¢ {besoin}", normal_style))

                    story.append(Spacer(1, 15))

            # Nouvelle page pour l'analyse de march√©
            story.append(PageBreak())

            # ANALYSE DE MARCH√â
            story.append(Paragraph("ANALYSE DU MARCH√â", heading_style))

            dm = resultats['donnees_marche']

            # Tableau de distribution des scores
            score_dist = dm['distribution_scores']
            score_data = [
                ['Niveau de correspondance', 'Nombre de candidats', 'Pourcentage'],
                ['Excellent (80%+)', str(score_dist['excellent_80_plus']), f"{score_dist['excellent_80_plus']/dm['total_analyses']*100:.1f}%"],
                ['Bon (60-79%)', str(score_dist['bon_60_79']), f"{score_dist['bon_60_79']/dm['total_analyses']*100:.1f}%"],
                ['Moyen (40-59%)', str(score_dist['moyen_40_59']), f"{score_dist['moyen_40_59']/dm['total_analyses']*100:.1f}%"],
                ['Faible (<40%)', str(score_dist['faible_moins_40']), f"{score_dist['faible_moins_40']/dm['total_analyses']*100:.1f}%"]
            ]

            score_table = Table(score_data, colWidths=[2*inch, 1.5*inch, 1.5*inch])
            score_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E4057')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(score_table)
            story.append(Spacer(1, 20))

            # Distribution par exp√©rience
            story.append(Paragraph("Distribution par niveau d'exp√©rience:", subheading_style))
            exp_dist = dm['distribution_experience']
            exp_data = [
                ['Niveau d\'exp√©rience', 'Nombre de candidats'],
                ['Junior (0-2 ans)', str(exp_dist['junior_0_2'])],
                ['Confirm√© (3-5 ans)', str(exp_dist['confirme_3_5'])],
                ['Senior (6-10 ans)', str(exp_dist['senior_6_10'])],
                ['Expert (10+ ans)', str(exp_dist['expert_10_plus'])]
            ]

            exp_table = Table(exp_data, colWidths=[3*inch, 2*inch])
            exp_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#048A81')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(exp_table)
            story.append(Spacer(1, 20))

            # Top cat√©gories
            story.append(Paragraph("Top 5 cat√©gories de candidats:", subheading_style))
            cat_list = []
            for i, (categorie, nombre) in enumerate(list(dm['categories_top'].items())[:5], 1):
                cat_list.append(f"{i}. {categorie}: {nombre} candidats")
            story.append(Paragraph("<br/>".join(cat_list), normal_style))
            story.append(Spacer(1, 20))

            # RAPPORT GEMINI
            story.append(Paragraph("RAPPORT EX√âCUTIF GEMINI", heading_style))

            # V√©rifier si le rapport Gemini existe et n'est pas vide
            rapport_gemini = resultats.get('rapport_executif', '')
            if rapport_gemini and rapport_gemini.strip() and "non disponible" not in rapport_gemini.lower():
                # Diviser le rapport en paragraphes pour un meilleur formatage
                paragraphes_gemini = rapport_gemini.split('\n\n')
                for paragraphe in paragraphes_gemini:
                    if paragraphe.strip():
                        # Identifier les titres (contiennent des majuscules ou des :)
                        if ':' in paragraphe or paragraphe.isupper() or paragraphe.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.')):
                            story.append(Paragraph(f"<b>{paragraphe.strip()}</b>", normal_style))
                        else:
                            story.append(Paragraph(paragraphe.strip(), normal_style))
                        story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("<i>Rapport Gemini non disponible - Analyse effectu√©e en mode de base.</i>", normal_style))
                story.append(Paragraph("L'analyse a √©t√© r√©alis√©e avec les algorithmes de base du syst√®me. "
                                     "Pour obtenir un rapport Gemini complet, configurez l'authentification "
                                     "Hugging Face ou utilisez un mod√®le alternatif.", normal_style))

            story.append(Spacer(1, 20))

            # RECOMMANDATIONS STRAT√âGIQUES
            story.append(Paragraph("RECOMMANDATIONS STRAT√âGIQUES", heading_style))

            # Actions recommand√©es selon la d√©cision
            if resultats['recommandation'] == "EMBAUCHER":
                story.append(Paragraph("<b>D√©cision: PROC√âDER √Ä L'EMBAUCHE</b>", subheading_style))
                story.append(Paragraph("Justification: Plusieurs candidats excellents identifi√©s avec un fort potentiel de r√©ussite.", normal_style))
                actions = [
                    "Planifier les entretiens avec les 3 meilleurs candidats",
                    "Pr√©parer des √©valuations techniques sp√©cifiques au poste",
                    "V√©rifier les r√©f√©rences et certifications des candidats s√©lectionn√©s",
                    "N√©gocier les conditions contractuelles et salariales",
                    "Organiser l'int√©gration et la formation d'accueil"
                ]
            elif resultats['recommandation'] == "√âVALUER":
                story.append(Paragraph("<b>D√©cision: √âVALUATION APPROFONDIE REQUISE</b>", subheading_style))
                story.append(Paragraph("Justification: Candidats prometteurs identifi√©s n√©cessitant une analyse plus pouss√©e.", normal_style))
                actions = [
                    "Conduire des entretiens techniques d√©taill√©s",
                    "√âvaluer les besoins de formation et d'accompagnement",
                    "Consid√©rer une p√©riode d'essai ou un projet pilote",
                    "√âlargir la recherche si les r√©sultats ne sont pas concluants",
                    "R√©viser les crit√®res de s√©lection si n√©cessaire"
                ]
            else:
                story.append(Paragraph("<b>D√©cision: √âLARGIR LA RECHERCHE</b>", subheading_style))
                story.append(Paragraph("Justification: Le pool actuel de candidats ne r√©pond pas suffisamment aux exigences du poste.", normal_style))
                actions = [
                    "R√©viser et ajuster les crit√®res de s√©lection",
                    "√âlargir les sources de recrutement (r√©seaux, cabinets sp√©cialis√©s)",
                    "Consid√©rer des profils en reconversion avec formation",
                    "√âvaluer les possibilit√©s de promotion interne",
                    "Revoir le budget et les conditions propos√©es"
                ]

            story.append(Paragraph("<b>Actions prioritaires:</b>", normal_style))
            for i, action in enumerate(actions, 1):
                story.append(Paragraph(f"{i}. {action}", normal_style))

            story.append(Spacer(1, 20))

            # ANALYSE FINANCI√àRE
            story.append(Paragraph("ANALYSE FINANCI√àRE", heading_style))

            if resultats['budget'][0] > 0:
                budget_data = [
                    ['M√©trique', 'Valeur'],
                    ['Fourchette salariale', f"{resultats['budget'][0]:,} - {resultats['budget'][1]:,} ‚Ç¨/an"],
                    ['Co√ªt moyen estim√©', f"{(resultats['budget'][0] + resultats['budget'][1]) // 2:,} ‚Ç¨/an"],
                    ['Timeline de recrutement', resultats['timeline']]
                ]

                if resultats['candidats_top']:
                    meilleur_candidat = resultats['candidats_top'][0]
                    budget_data.append(['Meilleur candidat (co√ªt)', f"{meilleur_candidat.cout_estime:,} ‚Ç¨/an"])
                    budget_data.append(['Type de contrat sugg√©r√©', meilleur_candidat.contrat_recommande])

                budget_table = Table(budget_data, colWidths=[2.5*inch, 2.5*inch])
                budget_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E4057')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                story.append(budget_table)
            else:
                story.append(Paragraph("Budget √† d√©finir selon les profils s√©lectionn√©s.", normal_style))

            story.append(Spacer(1, 20))

            # CONCLUSION ET PROCHAINES √âTAPES
            story.append(Paragraph("CONCLUSION", heading_style))

            conclusion_text = f"""
            Cette analyse a permis d'√©valuer {dm['total_analyses']} candidats pour le poste de {resultats['rfp'].titre}
            chez {resultats['rfp'].entreprise}. Le syst√®me a identifi√© {score_dist['excellent_80_plus']} candidats excellents
            et {score_dist['bon_60_79']} candidats de bon niveau.

            La recommandation principale est de <b>{resultats['recommandation']}</b> avec une timeline estim√©e de {resultats['timeline']}.

            Les analyses Gemini ont apport√© une √©valuation qualitative approfondie des candidats les plus prometteurs,
            incluant des recommandations sp√©cifiques pour les entretiens et l'int√©gration.
            """

            story.append(Paragraph(conclusion_text, normal_style))
            story.append(Spacer(1, 20))

            # Footer avec m√©tadonn√©es
            story.append(Spacer(1, 30))
            footer_style = ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=8,
                textColor=colors.grey,
                alignment=TA_CENTER
            )

            story.append(Paragraph("_" * 80, footer_style))
            story.append(Paragraph(f"Rapport g√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M:%S')}", footer_style))
            story.append(Paragraph("Syst√®me de Recrutement Fran√ßais avec Intelligence Artificielle", footer_style))
            story.append(Paragraph(f"Fichier: rapport_recrutement_{timestamp}.pdf", footer_style))

            # G√©n√©ration du PDF
            doc.build(story)

            return f"rapport_recrutement_{timestamp}.pdf"

        except ImportError:
            print("‚ö†Ô∏è  ReportLab non install√©. Installation automatique...")
            try:
                import subprocess
                import sys
                subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab"])
                print("‚úÖ ReportLab install√©. Relancez la fonction.")
                return None
            except Exception as e:
                print(f"‚ùå Impossible d'installer ReportLab: {e}")
                print("üí° Installez manuellement avec: pip install reportlab")
                return None

        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration PDF: {e}")
            print("üí° Le PDF n'a pas pu √™tre cr√©√©, mais les autres fichiers sont disponibles")
            return None


print("‚úÖ Syst√®me de Recrutement Fran√ßais complet pr√™t")

def main(chemin_rfp_pdf: str, chemin_dataset_csv: str = "UpdatedResumeDataSet.csv",
         modele_gemini: str = "google/gemma-2b-it", sauvegarder: bool = True):
    """
    Fonction principale d'analyse de recrutement fran√ßais

    Args:
        chemin_rfp_pdf: Chemin vers le fichier PDF du RFP
        chemin_dataset_csv: Chemin vers le dataset de CVs (d√©faut: UpdatedResumeDataSet.csv)
        modele_gemini: Mod√®le Gemini √† utiliser (d√©faut: google/gemma-2b-it)
        sauvegarder: Sauvegarder les r√©sultats (d√©faut: True)

    Returns:
        Dict: R√©sultats complets de l'analyse
    """

    print("üá´üá∑ SYST√àME DE RECRUTEMENT FRAN√áAIS AVEC GEMINI")
    print("=" * 55)
    print(f"üìÑ RFP: {chemin_rfp_pdf}")
    print(f"üìä Dataset: {chemin_dataset_csv}")
    print(f"ü§ñ Mod√®le: {modele_gemini}")
    print("=" * 55)

    try:
        # V√©rification des fichiers
        import os
        if not os.path.exists(chemin_rfp_pdf):
            raise FileNotFoundError(f"Fichier RFP non trouv√©: {chemin_rfp_pdf}")

        if not os.path.exists(chemin_dataset_csv):
            raise FileNotFoundError(f"Dataset non trouv√©: {chemin_dataset_csv}")

        # Initialisation du syst√®me
        print("\n‚öôÔ∏è INITIALISATION DU SYST√àME")
        systeme = SystemeRecrutementFrancais(modele_gemini)

        # Analyse compl√®te
        print("\nüîç LANCEMENT DE L'ANALYSE COMPL√àTE")
        resultats = systeme.analyser_recrutement_complet(chemin_rfp_pdf, chemin_dataset_csv)

        if not resultats or not resultats['rfp']:
            print("‚ùå √âchec de l'analyse")
            return None

        # Affichage des r√©sultats
        systeme.afficher_resultats(resultats)

        # Sauvegarde
        if sauvegarder:
            print("\nüíæ SAUVEGARDE DES R√âSULTATS")
            fichier_sauvegarde = systeme.sauvegarder_resultats(resultats)
            resultats['fichier_sauvegarde'] = fichier_sauvegarde

        # R√©sum√© final
        print("\nüéâ ANALYSE TERMIN√âE AVEC SUCC√àS!")
        print("=" * 40)

        candidats_top = resultats['candidats_top']
        if candidats_top:
            meilleur = candidats_top[0]
            print(f"üèÜ Meilleur candidat: #{meilleur.id} ({meilleur.score_match:.1%})")
            print(f"üí∞ Budget estim√©: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} ‚Ç¨")
            print(f"‚è±Ô∏è Timeline: {resultats['timeline']}")
            print(f"üéØ Recommandation: {resultats['recommandation']}")

        print("=" * 40)

        return resultats

    except FileNotFoundError as e:
        print(f"‚ùå Erreur fichier: {e}")
        print("üí° V√©rifiez les chemins des fichiers")
        return None

    except Exception as e:
        print(f"‚ùå Erreur inattendue: {e}")
        print("üí° V√©rifiez les logs ci-dessus pour plus de d√©tails")
        import traceback
        traceback.print_exc()
        return None

def analyser_rfp_simple(chemin_pdf: str):
    """Analyse simple d'un RFP pour pr√©visualisation (sans Gemini)"""

    print("üîç ANALYSE RAPIDE DU RFP (MODE DE BASE)")
    print("-" * 40)

    try:
        parseur = ParseurRFPFrancais()
        rfp = parseur.analyser_rfp_complet(chemin_pdf)

        print(f"‚úÖ RFP analys√© avec succ√®s")
        print(f"   Titre: {rfp.titre}")
        print(f"   Entreprise: {rfp.entreprise}")
        print(f"   Secteur: {rfp.secteur}")
        print(f"   Exp√©rience requise: {rfp.experience_min_ans} ans")
        print(f"   Comp√©tences obligatoires ({len(rfp.competences_obligatoires)}):")

        for i, comp in enumerate(rfp.competences_obligatoires[:8], 1):
            print(f"      {i}. {comp}")

        if len(rfp.competences_obligatoires) > 8:
            print(f"      ... et {len(rfp.competences_obligatoires) - 8} autres")

        print(f"   Score de confiance: {rfp.score_confiance:.1%}")

        return rfp

    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return None

def lister_modeles_gemini():
    """Liste les mod√®les Gemini disponibles"""

    modeles = {
        "google/gemma-2b-it": {
            "taille": "2B param√®tres",
            "vitesse": "üöÄ Rapide",
            "qualite": "‚≠ê‚≠ê‚≠ê Bonne",
            "usage": "Id√©al pour tests et analyses rapides"
        },
        "google/gemma-7b-it": {
            "taille": "7B param√®tres",
            "vitesse": "üêå Plus lent",
            "qualite": "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente",
            "usage": "Recommand√© pour analyses finales"
        }
    }

    print("ü§ñ MOD√àLES GEMINI DISPONIBLES")
    print("=" * 35)

    for nom, info in modeles.items():
        print(f"\nüì¶ {nom}")
        print(f"   Taille: {info['taille']}")
        print(f"   Vitesse: {info['vitesse']}")
        print(f"   Qualit√©: {info['qualite']}")
        print(f"   Usage: {info['usage']}")

def verifier_installation():
    """V√©rifie que toutes les d√©pendances sont install√©es"""

    print("üîß V√âRIFICATION DE L'INSTALLATION")
    print("-" * 35)

    dependances = [
        ('pandas', 'pandas'),
        ('numpy', 'numpy'),
        ('transformers', 'transformers'),
        ('torch', 'torch'),
        ('sklearn', 'scikit-learn'),
        ('nltk', 'nltk'),
        ('PyPDF2', 'PyPDF2'),
        ('pdfplumber', 'pdfplumber')
    ]

    manquantes = []

    for module, nom_pip in dependances:
        try:
            __import__(module)
            print(f"‚úÖ {module}")
        except ImportError:
            print(f"‚ùå {module} - Installer avec: pip install {nom_pip}")
            manquantes.append(nom_pip)

    if manquantes:
        print(f"\nüí° Commande d'installation compl√®te:")
        print(f"pip install {' '.join(manquantes)}")
        return False
    else:
        print(f"\n‚úÖ Toutes les d√©pendances sont install√©es!")
        return True

def aide_utilisation():
    """Affiche l'aide d'utilisation"""

    print("üìñ GUIDE D'UTILISATION")
    print("=" * 25)

    print("\nüöÄ UTILISATION BASIQUE:")
    print("```python")
    print("# Analyse compl√®te avec param√®tres par d√©faut")
    print("resultats = main('mon_rfp.pdf')")
    print("")
    print("# Avec param√®tres personnalis√©s")
    print("resultats = main(")
    print("    chemin_rfp_pdf='rfp_beynost.pdf',")
    print("    chemin_dataset_csv='UpdatedResumeDataSet.csv',")
    print("    modele_gemini='google/gemma-7b-it',")
    print("    sauvegarder=True")
    print(")")
    print("```")

    print("\nüîç ANALYSE RAPIDE RFP:")
    print("```python")
    print("# Pr√©visualisation rapide d'un RFP")
    print("rfp = analyser_rfp_simple('mon_rfp.pdf')")
    print("```")

    print("\n‚öôÔ∏è FONCTIONS UTILES:")
    print("```python")
    print("# V√©rifier l'installation")
    print("verifier_installation()")
    print("")
    print("# Lister les mod√®les disponibles")
    print("lister_modeles_gemini()")
    print("")
    print("# Afficher cette aide")
    print("aide_utilisation()")
    print("```")

    print("\nüìÅ STRUCTURE DES R√âSULTATS:")
    print("- resultats['rfp']: Analyse du RFP")
    print("- resultats['candidats_top']: Top candidats")
    print("- resultats['donnees_marche']: Analyse march√©")
    print("- resultats['rapport_executif']: Rapport Gemini")
    print("- resultats['recommandation']: Decision finale")

def exemple_utilisation():
    """Exemples d'utilisation du syst√®me"""

    print("üí° EXEMPLES D'UTILISATION")
    print("=" * 30)

    print("\n1Ô∏è‚É£ ANALYSE COMPL√àTE BASIQUE:")
    print("   resultats = main('beynost_rfp.pdf')")

    print("\n2Ô∏è‚É£ AVEC MOD√àLE PUISSANT:")
    print("   resultats = main('rfp_complexe.pdf', modele_gemini='google/gemma-7b-it')")

    print("\n3Ô∏è‚É£ PR√âVISUALISATION RFP:")
    print("   rfp = analyser_rfp_simple('nouveau_rfp.pdf')")

    print("\n4Ô∏è‚É£ ANALYSE SANS SAUVEGARDE:")
    print("   resultats = main('rfp_test.pdf', sauvegarder=False)")

    print("\n5Ô∏è‚É£ ACC√àS AUX R√âSULTATS:")
    print("   meilleur_candidat = resultats['candidats_top'][0]")
    print("   print(f'Score: {meilleur_candidat.score_match:.1%}')")

# ============================================================================
# POINT D'ENTR√âE PRINCIPAL
# ============================================================================

if __name__ == "__main__":
    print("üá´üá∑ AGENT DE RECRUTEMENT FRAN√áAIS AVEC GEMINI")
    print("=" * 50)
    print("üìñ Tapez aide_utilisation() pour voir les exemples")
    print("üîß Tapez verifier_installation() pour v√©rifier les d√©pendances")
    print("ü§ñ Tapez lister_modeles_gemini() pour voir les mod√®les")
    print("=" * 50)

    # Exemple d'utilisation par d√©faut (√† personnaliser)
    print("\nüí° EXEMPLE D'UTILISATION:")
    print("resultats = main('votre_rfp.pdf', 'UpdatedResumeDataSet.csv')")
    print("\nüöÄ Pr√™t √† analyser vos RFPs fran√ßais!")

# D√âCOMMENTEZ LA LIGNE CI-DESSOUS POUR LANCER UNE ANALYSE
resoudre_probleme_authentification()
resultats = main('/kaggle/input/recruitment-input/18_CCTP.pdf', '/kaggle/input/recruitment-input/UpdatedResumeDataSet.csv')

