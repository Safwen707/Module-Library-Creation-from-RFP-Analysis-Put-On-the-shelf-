# -*- coding: utf-8 -*-
"""recruitment-agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10mhJ3oTvXfu-MtA042BoUN7RxbjtHdS9
"""

!pip install transformers torch pandas numpy scikit-learn nltk PyPDF2 pdfplumber

import pandas as pd
import numpy as np
import re
import json
import torch
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Transformers et Gemini
from transformers import AutoTokenizer, AutoModelForCausalLM, GenerationConfig
import torch.nn.functional as F

# PDF et text processing
import PyPDF2
import pdfplumber
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import nltk
from collections import Counter, defaultdict

# Téléchargement NLTK si nécessaire
try:
    nltk.data.find('tokenizers/punkt')
    nltk.data.find('corpora/stopwords')
except LookupError:
    nltk.download('punkt', quiet=True)
    nltk.download('stopwords', quiet=True)

from nltk.corpus import stopwords

print("✅ Bibliothèques importées avec succès")

#Modify this code bit
#Should add ur own key here

from kaggle_secrets import UserSecretsClient
user_secrets = UserSecretsClient()
HF_key = user_secrets.get_secret("HF_API_KEY")

def configurer_huggingface():
    """Configure l'authentification Hugging Face pour accéder à Gemma"""

    print("🔐 CONFIGURATION HUGGING FACE")
    print("-" * 35)

    try:
        from huggingface_hub import login, HfApi
        import os

        # Vérifier si un token existe déjà
        token_existant = HF_key

        if token_existant:
            print("✅ Token Hugging Face trouvé dans les variables d'environnement")
            try:
                login(token=token_existant, add_to_git_credential=False)
                print("✅ Authentification réussie avec le token existant")
                return True
            except Exception as e:
                print(f"❌ Échec avec le token existant: {e}")

        # Demander le token à l'utilisateur
        print("\n📋 ÉTAPES POUR OBTENIR VOTRE TOKEN HUGGING FACE:")
        print("1. Allez sur https://huggingface.co/settings/tokens")
        print("2. Créez un nouveau token (Read access suffit)")
        print("3. Copiez le token généré")
        print("4. Collez-le ci-dessous")
        print("\n💡 Le token ressemble à: hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")

        token = input("\n🔑 Entrez votre token Hugging Face: ").strip()

        if not token.startswith('hf_'):
            print("⚠️  Attention: Le token devrait commencer par 'hf_'")
            confirmation = input("Continuer quand même? (o/n): ").lower()
            if confirmation != 'o':
                return False

        # Tenter la connexion
        login(token=token, add_to_git_credential=False)

        # Vérifier l'accès à Gemma
        api = HfApi()
        try:
            model_info = api.model_info("google/gemma-2b-it", token=token)
            print("✅ Accès confirmé au modèle Gemma!")

            # Sauvegarder le token pour les prochaines fois
            choix_sauvegarde = input("💾 Sauvegarder le token localement? (o/n): ").lower()
            if choix_sauvegarde == 'o':
                os.environ['HF_TOKEN'] = token
                print("✅ Token sauvegardé pour cette session")

            return True

        except Exception as e:
            print(f"❌ Erreur d'accès à Gemma: {e}")
            print("💡 Vérifiez que vous avez accepté les conditions d'utilisation:")
            print("   https://huggingface.co/google/gemma-2b-it")
            return False

    except ImportError:
        print("❌ Erreur: huggingface_hub non installé")
        print("📦 Installez avec: pip install huggingface_hub")
        return False

    except Exception as e:
        print(f"❌ Erreur inattendue: {e}")
        return False

def utiliser_modele_alternatif():
    """Propose des modèles alternatifs qui ne nécessitent pas d'authentification"""

    print("\n🔄 MODÈLES ALTERNATIFS DISPONIBLES")
    print("-" * 40)

    modeles_libres = {
        "microsoft/DialoGPT-medium": {
            "description": "Modèle conversationnel Microsoft",
            "avantages": "Pas d'auth requise, bon pour dialogue",
            "inconvenients": "Moins spécialisé pour l'analyse"
        },
        "distilbert-base-uncased": {
            "description": "Version allégée de BERT",
            "avantages": "Rapide, pas d'auth, bon pour classification",
            "inconvenients": "Pas génératif, limité pour rapports"
        },
        "gpt2": {
            "description": "GPT-2 d'OpenAI (ancien mais fonctionnel)",
            "avantages": "Pas d'auth, génératif, bien documenté",
            "inconvenients": "Moins performant que Gemma"
        }
    }

    print("Modèles disponibles sans authentification:")
    for i, (nom, info) in enumerate(modeles_libres.items(), 1):
        print(f"\n{i}. {nom}")
        print(f"   Description: {info['description']}")
        print(f"   ✅ Avantages: {info['avantages']}")
        print(f"   ⚠️  Limites: {info['inconvenients']}")

    print(f"\n4. Continuer sans Gemini (analyse de base uniquement)")

    choix = input(f"\nChoisissez une option (1-4): ").strip()

    if choix == "1":
        return "microsoft/DialoGPT-medium"
    elif choix == "2":
        return "distilbert-base-uncased"
    elif choix == "3":
        return "gpt2"
    elif choix == "4":
        return None  # Mode sans Gemini
    else:
        print("Choix invalide, utilisation de GPT-2 par défaut")
        return "gpt2"

def resoudre_probleme_authentification():
    """Fonction principale pour résoudre les problèmes d'authentification"""

    print("🚨 PROBLÈME D'AUTHENTIFICATION DÉTECTÉ")
    print("=" * 45)

    print("\nCe problème survient car Gemma nécessite:")
    print("1. ✅ Un compte Hugging Face gratuit")
    print("2. ✅ Accepter les conditions d'utilisation du modèle")
    print("3. ✅ Un token d'authentification")

    print(f"\n🛠️  SOLUTIONS DISPONIBLES:")
    print("1. Configurer l'authentification Hugging Face (RECOMMANDÉ)")
    print("2. Utiliser un modèle alternatif sans authentification")
    print("3. Continuer sans Gemini (analyse de base uniquement)")

    choix = input(f"\nQue souhaitez-vous faire? (1-3): ").strip()

    if choix == "1":
        if configurer_huggingface():
            return "google/gemma-2b-it"  # Modèle original
        else:
            print("\n❌ Configuration échouée")
            return utiliser_modele_alternatif()

    elif choix == "2":
        return utiliser_modele_alternatif()

    elif choix == "3":
        print("✅ Continuation en mode analyse de base uniquement")
        return None

    else:
        print("Choix invalide, utilisation du mode de base")
        return None

print("✅ Configuration d'authentification prête")

@dataclass
class RFPFrancais:
    """Structure pour RFP français"""
    titre: str
    entreprise: str
    secteur: str
    description: str
    competences_obligatoires: List[str]
    competences_souhaitees: List[str]
    certifications_requises: List[str]
    experience_min_ans: int
    types_contrat: List[str]
    localisation: str
    delais: str
    budget: str
    texte_brut: str
    score_confiance: float
    niveau_poste: str = "Confirmé"
    type_role: str = "Technique"

@dataclass
class ProfilCandidat:
    """Profil candidat analysé"""
    id: int
    categorie: str
    texte_cv: str
    competences_trouvees: List[str]
    certifications: List[str]
    experience_ans: int
    score_match: float
    couverture_obligatoire: float
    couverture_souhaitee: float
    match_certifications: bool
    match_experience: bool
    contrat_recommande: str
    cout_estime: int
    forces: List[str]
    lacunes: List[str]
    niveau_risque: str
    recommandation_gemini: str = ""
    adequation_technique: int = 0
    pertinence_experience: int = 0
    axes_entretien: List[str] = None
    besoins_integration: List[str] = None

class AgentGeminiFrancais:
    """Agent Gemini optimisé pour le recrutement français"""

    def __init__(self, modele: str = "google/gemma-2b-it"):
        self.nom_modele = modele
        self.device = self._configurer_device()

        print(f"🔄 Chargement du modèle Gemini : {modele}")
        print(f"📱 Device utilisé : {self.device}")

        # Chargement du modèle
        self.tokenizer = AutoTokenizer.from_pretrained(
            modele, trust_remote_code=True
        )

        self.model = AutoModelForCausalLM.from_pretrained(
            modele,
            torch_dtype=torch.float16 if self.device != "cpu" else torch.float32,
            device_map="auto" if self.device != "cpu" else None,
            trust_remote_code=True
        )

        # Configuration pad token
        if self.tokenizer.pad_token is None:
            self.tokenizer.pad_token = self.tokenizer.eos_token

        # Configuration génération
        self.config_generation = GenerationConfig(
            max_new_tokens=1024,
            temperature=0.3,
            top_p=0.9,
            do_sample=True,
            pad_token_id=self.tokenizer.eos_token_id
        )

        print("✅ Modèle Gemini chargé avec succès")

    def _configurer_device(self) -> str:
        """Configure le device optimal"""
        if torch.cuda.is_available():
            device = "cuda"
            print(f"🚀 CUDA disponible : {torch.cuda.get_device_name()}")
        elif hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
            device = "mps"
            print("🍎 MPS (Apple Silicon) disponible")
        else:
            device = "cpu"
            print("💻 Utilisation CPU")
        return device

    def generer_reponse(self, prompt: str, tokens_max: int = 1024) -> str:
        """Génère une réponse avec Gemini"""

        # Format prompt pour Gemma
        prompt_formate = f"<start_of_turn>user\n{prompt}<end_of_turn>\n<start_of_turn>model\n"

        # Tokenisation
        inputs = self.tokenizer(
            prompt_formate,
            return_tensors="pt",
            truncation=True,
            max_length=2048
        )

        if self.device != "cpu":
            inputs = inputs.to(self.device)

        # Génération
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                generation_config=self.config_generation,
                max_new_tokens=tokens_max,
                pad_token_id=self.tokenizer.eos_token_id
            )

        # Décodage
        reponse = self.tokenizer.decode(
            outputs[0][inputs.input_ids.shape[1]:],
            skip_special_tokens=True
        )

        return reponse.strip()

    def analyser_rfp_francais(self, texte_rfp: str, donnees_extraites: dict) -> Dict:
        """Analyse la qualité d'extraction du RFP français"""

        prompt = f"""
Tu es un expert en recrutement français. Analyse ce RFP français et évalue la qualité de l'extraction.

TEXTE RFP (extrait):
{texte_rfp[:2000]}...

DONNÉES EXTRAITES:
- Titre: {donnees_extraites.get('titre', 'Non trouvé')}
- Compétences obligatoires: {', '.join(donnees_extraites.get('competences_obligatoires', [])[:8])}
- Compétences souhaitées: {', '.join(donnees_extraites.get('competences_souhaitees', [])[:5])}
- Expérience requise: {donnees_extraites.get('experience_min_ans', 0)} ans
- Certifications: {', '.join(donnees_extraites.get('certifications_requises', [])[:3])}

TÂCHES:
1. Noter la qualité de l'extraction (1-10)
2. Identifier les exigences manquantes importantes
3. Suggérer 3-5 compétences additionnelles pertinentes
4. Classer le niveau du poste (Junior/Confirmé/Senior/Expert)
5. Identifier le type de rôle (Technique/Management/Conseil/Commercial)

Format de réponse:
QUALITE: [1-10]
MANQUANT: [exigences critiques manquantes ou "Rien"]
COMPETENCES_SUPP: [3-5 compétences suggérées]
NIVEAU: [Junior/Confirmé/Senior/Expert]
TYPE_ROLE: [Technique/Management/Conseil/Commercial]
"""

        reponse = self.generer_reponse(prompt, 512)
        return self._parser_analyse_rfp(reponse)

    def analyser_candidat_francais(self, candidat: dict, rfp: dict) -> Dict:
        """Analyse approfondie d'un candidat français"""

        prompt = f"""
Tu es un consultant RH expert. Analyse ce candidat français pour le poste.

POSTE:
- Titre: {rfp.get('titre', 'Poste inconnu')}
- Compétences clés: {', '.join(rfp.get('competences_obligatoires', [])[:8])}
- Expérience: {rfp.get('experience_min_ans', 0)}+ ans
- Secteur: {rfp.get('secteur', 'Non spécifié')}

CANDIDAT:
- Catégorie: {candidat.get('categorie', 'Inconnue')}
- Expérience: {candidat.get('experience_ans', 0)} ans
- Compétences: {', '.join(candidat.get('competences_trouvees', [])[:8])}
- Score: {candidat.get('score_match', 0):.1%}
- CV (extrait): {candidat.get('texte_cv', '')[:400]}...

ANALYSE DEMANDÉE:
1. Adéquation technique (1-10)
2. Pertinence expérience (1-10)
3. Top 3 forces du candidat
4. Top 3 points d'attention
5. Axes d'entretien prioritaires
6. Besoins d'intégration/formation
7. Recommandation finale

Format:
TECHNIQUE: [1-10]
EXPERIENCE: [1-10]
FORCES: [3 forces principales]
POINTS_ATTENTION: [3 points d'attention]
ENTRETIEN: [3 axes d'entretien]
INTEGRATION: [besoins formation/accompagnement]
RECOMMANDATION: [Embaucher/Evaluer/Rejeter]
JUSTIFICATION: [explication courte]
"""

        reponse = self.generer_reponse(prompt, 1024)
        return self._parser_analyse_candidat(reponse)

    def generer_rapport_executif(self, top_candidats: List, rfp_data: dict, donnees_marche: dict) -> str:
        """Génère un rapport exécutif français avec gestion d'erreurs"""

        try:
            candidates_summary = []
            for i, candidat in enumerate(top_candidats[:5], 1):
                # Vérifier si c'est un objet ProfilCandidat ou un dictionnaire
                if hasattr(candidat, 'id'):  # C'est un objet ProfilCandidat
                    candidates_summary.append(
                        f"{i}. Candidat #{candidat.id} ({candidat.categorie}) - "
                        f"{candidat.score_match:.1%} - {candidat.experience_ans} ans"
                    )
                else:  # C'est un dictionnaire
                    candidates_summary.append(
                        f"{i}. Candidat #{candidat.get('id', 'N/A')} ({candidat.get('categorie', 'N/A')}) - "
                        f"{candidat.get('score_match', 0):.1%} - {candidat.get('experience_ans', 0)} ans"
                    )

            prompt = f"""
Tu es un consultant senior préparant un rapport exécutif pour un client français.

CONTEXTE MISSION:
- Poste: {rfp_data.get('titre', 'Poste inconnu')}
- Entreprise: {rfp_data.get('entreprise', 'Entreprise inconnue')}
- Secteur: {rfp_data.get('secteur', 'Non spécifié')}
- Compétences clés: {', '.join(rfp_data.get('competences_obligatoires', [])[:6])}
- Niveau: {rfp_data.get('experience_min_ans', 0)}+ ans

CANDIDATS IDENTIFIÉS:
{chr(10).join(candidates_summary)}

MARCHÉ:
- Total analysé: {donnees_marche.get('total_analyses', 0)}
- Score moyen: {donnees_marche.get('score_moyen', 0):.1%}
- Avec certifications: {donnees_marche.get('avec_certifications', 0)}

Génère un rapport exécutif professionnel français incluant:

1. SYNTHÈSE EXÉCUTIVE (2-3 phrases)
2. ÉTAT DU MARCHÉ (disponibilité talents)
3. CANDIDATS PRIORITAIRES (évaluation de chacun)
4. STRATÉGIE RECRUTEMENT (approche recommandée)
5. FACTEURS DE RISQUE (défis potentiels)
6. BUDGET & PLANNING
7. ACTIONS RECOMMANDÉES

Style: professionnel, concis, axé business.
"""

            response = self.generer_reponse(prompt, max_tokens=1024)
            return response

        except Exception as e:
            print(f"Erreur dans generer_rapport_executif: {e}")

    def _parser_analyse_rfp(self, reponse: str) -> Dict:
        """Parse la réponse d'analyse RFP"""
        analyse = {
            'score_qualite': 5,
            'exigences_manquantes': [],
            'competences_supplementaires': [],
            'niveau_poste': 'Confirmé',
            'type_role': 'Technique'
        }

        try:
            lignes = reponse.split('\n')
            for ligne in lignes:
                ligne = ligne.strip()
                if ligne.startswith('QUALITE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['score_qualite'] = int(score[0])

                elif ligne.startswith('MANQUANT:'):
                    manquant = ligne.replace('MANQUANT:', '').strip()
                    if manquant and manquant.lower() not in ['rien', 'non', 'aucun']:
                        analyse['exigences_manquantes'] = [m.strip() for m in manquant.split(',')]

                elif ligne.startswith('COMPETENCES_SUPP:'):
                    comp = ligne.replace('COMPETENCES_SUPP:', '').strip()
                    if comp:
                        analyse['competences_supplementaires'] = [c.strip() for c in comp.split(',')]

                elif ligne.startswith('NIVEAU:'):
                    niveau = ligne.replace('NIVEAU:', '').strip()
                    if niveau:
                        analyse['niveau_poste'] = niveau

                elif ligne.startswith('TYPE_ROLE:'):
                    type_role = ligne.replace('TYPE_ROLE:', '').strip()
                    if type_role:
                        analyse['type_role'] = type_role

        except Exception as e:
            print(f"Attention: Erreur parsing RFP: {e}")

        return analyse

    def _parser_analyse_candidat(self, reponse: str) -> Dict:
        """Parse la réponse d'analyse candidat"""
        analyse = {
            'adequation_technique': 5,
            'pertinence_experience': 5,
            'forces': [],
            'points_attention': [],
            'axes_entretien': [],
            'besoins_integration': [],
            'recommandation': 'Evaluer',
            'justification': 'Analyse standard'
        }

        try:
            lignes = reponse.split('\n')
            for ligne in lignes:
                ligne = ligne.strip()
                if ligne.startswith('TECHNIQUE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['adequation_technique'] = int(score[0])

                elif ligne.startswith('EXPERIENCE:'):
                    score = re.findall(r'\d+', ligne)
                    if score:
                        analyse['pertinence_experience'] = int(score[0])

                elif ligne.startswith('FORCES:'):
                    forces = ligne.replace('FORCES:', '').strip()
                    if forces:
                        analyse['forces'] = [f.strip() for f in forces.split(',')][:3]

                elif ligne.startswith('POINTS_ATTENTION:'):
                    points = ligne.replace('POINTS_ATTENTION:', '').strip()
                    if points:
                        analyse['points_attention'] = [p.strip() for p in points.split(',')][:3]

                elif ligne.startswith('ENTRETIEN:'):
                    entretien = ligne.replace('ENTRETIEN:', '').strip()
                    if entretien:
                        analyse['axes_entretien'] = [e.strip() for e in entretien.split(',')][:3]

                elif ligne.startswith('INTEGRATION:'):
                    integration = ligne.replace('INTEGRATION:', '').strip()
                    if integration:
                        analyse['besoins_integration'] = [i.strip() for i in integration.split(',')][:3]

                elif ligne.startswith('RECOMMANDATION:'):
                    rec = ligne.replace('RECOMMANDATION:', '').strip()
                    if rec:
                        analyse['recommandation'] = rec

                elif ligne.startswith('JUSTIFICATION:'):
                    just = ligne.replace('JUSTIFICATION:', '').strip()
                    if just:
                        analyse['justification'] = just

        except Exception as e:
            print(f"Attention: Erreur parsing candidat: {e}")

        return analyse

print("✅ Agent Gemini Français prêt")

class ParseurRFPFrancais:
    """Parser optimisé pour les RFPs français"""

    def __init__(self):
        # Patterns français pour compétences
        self.patterns_competences = {
            'obligatoires': [
                r'compétences\s*(?:exigées?|obligatoires?|requises?|impératives?)[:\s]*([^.]{1,200})',
                r'(?:prérequis|pré-requis)\s*(?:obligatoires?)?[:\s]*([^.]{1,200})',
                r'maîtrise\s*(?:obligatoire|requise|exigée)[:\s]*([^.]{1,200})',
                r'indispensable[:\s]*([^.]{1,200})'
            ],
            'souhaitees': [
                r'compétences\s*(?:souhaitées?|désirées?|appréciées?)[:\s]*([^.]{1,200})',
                r'(?:atouts?|plus)[:\s]*([^.]{1,200})',
                r'serait\s*un\s*plus[:\s]*([^.]{1,200})',
                r'idéalement[:\s]*([^.]{1,200})'
            ],
            'techniques': [
                r'technologies?\s*(?:utilisées?|requises?)[:\s]*([^.]{1,200})',
                r'outils?[:\s]*([^.]{1,200})',
                r'langages?[:\s]*([^.]{1,200})',
                r'stack\s*technique[:\s]*([^.]{1,200})'
            ]
        }

        # Compétences techniques communes
        self.competences_communes = [
            'python', 'java', 'javascript', 'react', 'angular', 'vue', 'node.js',
            'sql', 'mysql', 'postgresql', 'mongodb', 'docker', 'kubernetes',
            'aws', 'azure', 'gcp', 'git', 'jenkins', 'agile', 'scrum',
            'machine learning', 'ia', 'data science', 'big data',
            'rgpd', 'gdpr', 'cybersécurité', 'audit', 'conformité', 'dpo',
            'gestion de projet', 'management', 'leadership', 'communication'
        ]

        # Patterns expérience
        self.patterns_experience = [
            r'(\d+)\s*(?:ans?|années?)\s*(?:d[\'e]\s*)?(?:expériences?)',
            r'(?:expériences?)\s*(?:de\s*)?(\d+)\s*(?:ans?|années?)',
            r'minimum\s*(\d+)\s*(?:ans?|années?)',
            r'au\s*moins\s*(\d+)\s*(?:ans?|années?)'
        ]

        # Secteurs français
        self.secteurs_francais = {
            'IT/Tech': ['informatique', 'technologie', 'digital', 'numérique'],
            'Public': ['public', 'administration', 'collectivité', 'mairie', 'ministère'],
            'Finance': ['banque', 'finance', 'assurance', 'gestion'],
            'Santé': ['santé', 'médical', 'pharmaceutique', 'hôpital'],
            'Conseil': ['conseil', 'consulting', 'expertise', 'audit'],
            'Industrie': ['industrie', 'manufacturier', 'production']
        }

    def extraire_texte_pdf(self, chemin_pdf: str) -> str:
        """Extrait le texte d'un PDF français"""
        texte = ""

        try:
            with pdfplumber.open(chemin_pdf) as pdf:
                for page in pdf.pages:
                    texte_page = page.extract_text()
                    if texte_page:
                        texte += texte_page + "\n"
        except Exception as e:
            print(f"Erreur pdfplumber: {e}")
            try:
                with open(chemin_pdf, 'rb') as fichier:
                    lecteur_pdf = PyPDF2.PdfReader(fichier)
                    for page in lecteur_pdf.pages:
                        texte += page.extract_text() + "\n"
            except Exception as e2:
                raise Exception(f"Impossible d'extraire le PDF: {e2}")

        return texte

    def analyser_rfp_complet(self, chemin_pdf: str) -> RFPFrancais:
        """Analyse complète d'un RFP français"""

        # Extraction texte
        texte_brut = self.extraire_texte_pdf(chemin_pdf)
        texte_nettoye = self._nettoyer_texte_francais(texte_brut)

        # Extractions
        titre = self._extraire_titre(texte_nettoye)
        entreprise = self._extraire_entreprise(texte_nettoye)
        secteur = self._extraire_secteur(texte_nettoye)
        description = self._extraire_description(texte_nettoye)

        comp_obligatoires = self._extraire_competences(texte_nettoye, 'obligatoires')
        comp_souhaitees = self._extraire_competences(texte_nettoye, 'souhaitees')
        comp_techniques = self._extraire_competences(texte_nettoye, 'techniques')

        # Fusion compétences si nécessaire
        if not comp_obligatoires and comp_techniques:
            comp_obligatoires = comp_techniques[:10]

        certifications = self._extraire_certifications(texte_nettoye)
        experience_ans = self._extraire_experience(texte_nettoye)
        types_contrat = self._extraire_types_contrat(texte_nettoye)
        localisation = self._extraire_localisation(texte_nettoye)
        delais = self._extraire_delais(texte_nettoye)
        budget = self._extraire_budget(texte_nettoye)

        # Score de confiance
        score_confiance = self._calculer_confiance(titre, comp_obligatoires, experience_ans)

        return RFPFrancais(
            titre=titre,
            entreprise=entreprise,
            secteur=secteur,
            description=description,
            competences_obligatoires=comp_obligatoires,
            competences_souhaitees=comp_souhaitees,
            certifications_requises=certifications,
            experience_min_ans=experience_ans,
            types_contrat=types_contrat,
            localisation=localisation,
            delais=delais,
            budget=budget,
            texte_brut=texte_brut,
            score_confiance=score_confiance
        )

    def _nettoyer_texte_francais(self, texte: str) -> str:
        """Nettoie le texte français"""
        import unicodedata
        texte = unicodedata.normalize('NFKD', texte)
        texte = re.sub(r'\s+', ' ', texte)
        return texte.strip()

    def _extraire_titre(self, texte: str) -> str:
        """Extrait le titre du poste"""
        lignes = texte.split('\n')[:15]

        indicateurs = ['poste', 'mission', 'offre', 'développeur', 'ingénieur', 'consultant', 'chef', 'responsable']

        for ligne in lignes:
            if any(ind in ligne.lower() for ind in indicateurs) and len(ligne.strip()) > 10:
                return re.sub(r'[^\w\s\-àâäéèêëïîôöùûüÿç]', '', ligne).strip()[:150]

        return "Poste non identifié"

    def _extraire_competences(self, texte: str, type_comp: str) -> List[str]:
        """Extrait les compétences selon le type"""
        competences = []
        texte_lower = texte.lower()

        patterns = self.patterns_competences.get(type_comp, [])

        for pattern in patterns:
            matches = re.finditer(pattern, texte_lower, re.IGNORECASE | re.DOTALL)
            for match in matches:
                comp_text = match.group(1)
                competences_parsees = self._parser_liste_competences(comp_text)
                competences.extend(competences_parsees)

        # Ajout compétences communes trouvées
        for comp in self.competences_communes:
            if comp.lower() in texte_lower and comp not in competences:
                competences.append(comp)

        return list(set([c.strip() for c in competences if len(c.strip()) > 2]))[:20]

    def _parser_liste_competences(self, texte_comp: str) -> List[str]:
        """Parse une liste de compétences"""
        separateurs = [',', ';', '•', '-', '\n', ' et ', ' ou ']

        competences = [texte_comp]
        for sep in separateurs:
            nouvelles_comp = []
            for comp in competences:
                nouvelles_comp.extend(comp.split(sep))
            competences = nouvelles_comp

        # Nettoyage
        competences_nettoyees = []
        for comp in competences:
            comp = comp.strip()
            comp = re.sub(r'^(?:maîtrise|connaissance|expérience)\s+(?:de\s+|en\s+)?', '', comp, flags=re.IGNORECASE)
            comp = re.sub(r'\s*\([^)]*\)', '', comp)

            if 2 <= len(comp) <= 50:
                competences_nettoyees.append(comp)

        return competences_nettoyees

    def _extraire_experience(self, texte: str) -> int:
        """Extrait les années d'expérience"""
        annees = []
        for pattern in self.patterns_experience:
            matches = re.findall(pattern, texte.lower())
            for match in matches:
                try:
                    annees.append(int(match))
                except ValueError:
                    continue
        return max(annees) if annees else 0

    def _extraire_entreprise(self, texte: str) -> str:
        """Extrait le nom de l'entreprise"""
        lignes = texte.split('\n')[:20]

        indicateurs = ['société', 'entreprise', 'groupe', 'cabinet', 'sarl', 'sas']

        for ligne in lignes:
            if any(ind in ligne.lower() for ind in indicateurs):
                entreprise = re.sub(r'[^\w\s\-àâäéèêëïîôöùûüÿç]', '', ligne).strip()
                if 3 < len(entreprise) < 100:
                    return entreprise

        return "Entreprise non identifiée"

    def _extraire_secteur(self, texte: str) -> str:
        """Extrait le secteur d'activité"""
        texte_lower = texte.lower()

        for secteur, mots_cles in self.secteurs_francais.items():
            if any(mot in texte_lower for mot in mots_cles):
                return secteur

        return "Secteur non identifié"

    def _extraire_description(self, texte: str) -> str:
        """Extrait la description du poste"""
        patterns = [
            r'(?:description|contexte|mission).*?(?=(?:compétences|qualifications|profil))',
            r'(?:missions?|rôles?).*?(?=(?:compétences|qualifications))'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower(), re.DOTALL)
            if match and len(match.group()) > 50:
                return match.group().strip()[:500]

        return "Description non extraite"

    def _extraire_certifications(self, texte: str) -> List[str]:
        """Extrait les certifications"""
        patterns = [
            r'certifications?\s*(?:requises?|exigées?)[:\s]*([^.]{1,100})',
            r'diplômes?\s*(?:requis|exigés)[:\s]*([^.]{1,100})'
        ]

        certifications = []
        for pattern in patterns:
            matches = re.finditer(pattern, texte.lower())
            for match in matches:
                cert_text = match.group(1)
                certifications.extend(self._parser_liste_competences(cert_text))

        return list(set(certifications))[:5]

    def _extraire_types_contrat(self, texte: str) -> List[str]:
        """Extrait les types de contrat"""
        contrats_map = {
            'cdi': 'CDI', 'cdd': 'CDD', 'freelance': 'Freelance',
            'stage': 'Stage', 'alternance': 'Alternance', 'expert': 'Expert'
        }

        contrats = []
        texte_lower = texte.lower()

        for cle, valeur in contrats_map.items():
            if cle in texte_lower:
                contrats.append(valeur)

        return list(set(contrats)) if contrats else ['CDI', 'CDD']

    def _extraire_localisation(self, texte: str) -> str:
        """Extrait la localisation"""
        patterns = [
            r'(?:lieu|localisation|région)[:\s]*([^.\n]{1,50})',
            r'(?:paris|lyon|marseille|toulouse|nice|bordeaux|lille)',
            r'\d{5}\s*[a-zA-ZÀ-ÿ]+',
            r'(?:télétravail|remote|hybride)'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                if match.groups():
                    return match.group(1).strip().title()
                else:
                    return match.group().strip().title()

        return "Localisation non spécifiée"

    def _extraire_delais(self, texte: str) -> str:
        """Extrait les délais"""
        patterns = [
            r'(?:durée|délai|planning)[:\s]*([^.\n]{1,100})',
            r'(\d+)\s*(?:mois|semaines?)',
            r'(?:début|démarrage)[:\s]*([^.\n]{1,50})'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                delai = match.group(1 if match.groups() else 0).strip()
                if delai and len(delai) > 3:
                    return delai

        return "Délai non spécifié"

    def _extraire_budget(self, texte: str) -> str:
        """Extrait le budget"""
        patterns = [
            r'(?:salaire|rémunération|budget)[:\s]*([^.\n]{1,100})',
            r'€\s*[\d\s,]+',
            r'\d+\s*k€'
        ]

        for pattern in patterns:
            match = re.search(pattern, texte.lower())
            if match:
                budget = match.group(1 if match.groups() else 0).strip()
                if budget and len(budget) > 3:
                    return budget

        return "Budget non spécifié"

    def _calculer_confiance(self, titre: str, competences: List[str], experience: int) -> float:
        """Calcule le score de confiance d'extraction"""
        score = 0.0

        if titre and titre != "Poste non identifié":
            score += 0.3

        if competences:
            score += 0.4
            if len(competences) >= 5:
                score += 0.1

        if experience > 0:
            score += 0.2

        return min(score, 1.0)

print("✅ Parser RFP Français prêt")

def analyse_recrutement_francais(pdf_path: str, csv_path: str = "UpdatedResumeDataSet.csv",
                                gemini_model: str = "google/gemma-2b-it"):
    """Fonction principale d'analyse de recrutement français"""

    print("🚀 DÉMARRAGE DE L'ANALYSE DE RECRUTEMENT FRANÇAIS")
    print("=" * 65)

    try:
        # Initialisation du système
        system = FrenchRecruitmentSystem(gemini_model)

        # Analyse du RFP français
        print("\n📄 Analyse du RFP français...")
        rfp_data = system.analyze_french_rfp_complete(pdf_path)

        print(f"✅ Analyse RFP terminée:")
        print(f"   Titre: {rfp_data['title']}")
        print(f"   Entreprise: {rfp_data['company']}")
        print(f"   Secteur: {rfp_data['sector']}")
        print(f"   Score qualité Gemini: {rfp_data.get('gemini_quality_score', 0)}/10")
        print(f"   Niveau: {rfp_data.get('gemini_difficulty_level', 'Non défini')}")
        print(f"   Compétences trouvées: {len(rfp_data['mandatory_skills'])}")

        # Chargement des candidats
        print(f"\n📊 Chargement des candidats depuis {csv_path}...")
        df = pd.read_csv(csv_path)
        candidates_data = []

        for idx, row in df.iterrows():
            candidates_data.append({
                'id': idx,
                'category': row['Category'],
                'resume_text': row['Resume']
            })

        print(f"✅ {len(candidates_data)} candidats chargés")

        # Analyse des candidats
        print(f"\n🤖 Analyse des candidats avec Gemini français...")
        analyzed_candidates = system.analyze_candidates_french(candidates_data, rfp_data)

        # Tri par score
        analyzed_candidates.sort(key=lambda x: x['match_score'], reverse=True)
        top_candidates = analyzed_candidates[:15]

        print(f"✅ Analyse terminée")

        # Génération des données de marché
        market_data = system.generate_french_market_data(analyzed_candidates)

        # Génération du rapport final
        print(f"\n📋 Génération du rapport exécutif français...")
        try:
            final_report = system.gemini.generate_french_executive_report(
                top_candidates, rfp_data, market_data
            )
        except Exception as e:
            print(f"Attention: Génération rapport Gemini échouée: {e}")
            final_report = "Rapport exécutif non disponible"

        # Affichage des résultats
        print("\n" + "=" * 80)
        print("🇫🇷 RÉSULTATS DE L'ANALYSE DE RECRUTEMENT FRANÇAIS")
        print("=" * 80)

        # Analyse RFP
        print(f"\n📄 ANALYSE RFP (Qualité Gemini: {rfp_data.get('gemini_quality_score', 0)}/10)")
        print("-" * 55)
        print(f"Poste: {rfp_data['title']}")
        print(f"Entreprise: {rfp_data['company']}")
        print(f"Secteur: {rfp_data['sector']}")
        print(f"Localisation: {rfp_data['location']}")
        print(f"Niveau: {rfp_data.get('gemini_difficulty_level', 'Non défini')}")
        print(f"Type de rôle: {rfp_data.get('gemini_role_type', 'Non défini')}")
        print(f"Expérience requise: {rfp_data['experience_years_min']} ans")
        print(f"Compétences clés: {', '.join(rfp_data['mandatory_skills'][:6])}")

        if rfp_data.get('gemini_additional_skills'):
            print(f"Compétences suggérées par Gemini: {', '.join(rfp_data['gemini_additional_skills'][:3])}")

        # Top candidats
        print(f"\n🏆 TOP CANDIDATS (Analyse Gemini Française)")
        print("-" * 50)

        for i, candidate in enumerate(top_candidates[:8], 1):
            print(f"\n{i}. Candidat #{candidate['id']} ({candidate['category']})")
            print(f"   Score de match: {candidate['match_score']:.1%}")
            print(f"   Expérience: {candidate['experience_years']} ans")
            print(f"   Contrat recommandé: {candidate['recommended_contract']}")
            print(f"   Coût estimé: {candidate['estimated_cost']:,} €/an")

            # Analyse Gemini si disponible
            if 'gemini_recommendation' in candidate:
                print(f"   Recommandation Gemini: {candidate['gemini_recommendation']}")
                print(f"   Adéquation technique: {candidate.get('gemini_technical_fit', 'N/A')}/10")
                print(f"   Pertinence expérience: {candidate.get('gemini_experience_relevance', 'N/A')}/10")

                if candidate.get('gemini_strengths'):
                    print(f"   Forces: {', '.join(candidate['gemini_strengths'][:2])}")

                if candidate.get('gemini_concerns'):
                    print(f"   Points d'attention: {', '.join(candidate['gemini_concerns'][:2])}")

                if candidate.get('gemini_contract_suggestion'):
                    print(f"   Contrat suggéré Gemini: {candidate['gemini_contract_suggestion']}")

        # Analyse du marché
        print(f"\n📊 ANALYSE DU MARCHÉ FRANÇAIS")
        print("-" * 35)
        print(f"Total analysé: {market_data['total_candidates_analyzed']} candidats")
        print(f"Score moyen: {market_data['average_match_score']:.1%}")

        print(f"\nDistribution par expérience:")
        exp_dist = market_data['experience_distribution']
        print(f"  Junior (0-2 ans): {exp_dist['junior_0_2_ans']}")
        print(f"  Confirmé (3-5 ans): {exp_dist['confirme_3_5_ans']}")
        print(f"  Senior (6-10 ans): {exp_dist['senior_6_10_ans']}")
        print(f"  Expert (10+ ans): {exp_dist['expert_10_plus_ans']}")

        print(f"\nDistribution des scores:")
        score_dist = market_data['score_distribution']
        print(f"  Excellent (80%+): {score_dist['excellent_80_plus']}")
        print(f"  Bon (60-79%): {score_dist['bon_60_79']}")
        print(f"  Correct (40-59%): {score_dist['correct_40_59']}")
        print(f"  Faible (<40%): {score_dist['faible_moins_40']}")

        print(f"\nCatégories principales:")
        for cat, count in list(market_data['top_categories'].items())[:5]:
            print(f"  {cat}: {count} candidats")

        # Rapport exécutif Gemini
        print(f"\n🤖 RAPPORT EXÉCUTIF GEMINI")
        print("-" * 35)
        print(final_report)

        # Recommandations
        print(f"\n📋 RECOMMANDATIONS STRATÉGIQUES")
        print("-" * 40)

        best_score = top_candidates[0]['match_score'] if top_candidates else 0
        excellent_count = score_dist['excellent_80_plus']

        if best_score >= 0.8 and excellent_count >= 2:
            recommendation = "EMBAUCHE RECOMMANDÉE"
            print("✅ Recommandation: PROCÉDER À L'EMBAUCHE")
            print("   Plusieurs candidats excellents identifiés")
            print("   Processus d'entretien à démarrer rapidement")
        elif best_score >= 0.6:
            recommendation = "ÉVALUATION APPROFONDIE"
            print("🔍 Recommandation: ÉVALUATION APPROFONDIE")
            print("   Candidats prometteurs nécessitant une analyse détaillée")
            print("   Entretiens techniques recommandés")
        else:
            recommendation = "ÉLARGIR LA RECHERCHE"
            print("🔄 Recommandation: ÉLARGIR LA RECHERCHE")
            print("   Pool actuel insuffisant")
            print("   Réviser les critères ou sources de recrutement")

        print(f"\n💰 ESTIMATION BUDGÉTAIRE")
        print("-" * 25)
        if top_candidates:
            costs = [c['estimated_cost'] for c in top_candidates[:5]]
            print(f"Fourchette coût: {min(costs):,} € - {max(costs):,} € / an")
            print(f"Coût moyen top 5: {int(np.mean(costs)):,} € / an")

        print(f"\n⏱️ PLANNING ESTIMÉ")
        print("-" * 20)
        if recommendation == "EMBAUCHE RECOMMANDÉE":
            print("  Phase entretiens: 2-3 semaines")
            print("  Intégration: 3-4 semaines")
            print("  Total: 5-7 semaines")
        elif recommendation == "ÉVALUATION APPROFONDIE":
            print("  Évaluation approfondie: 3-4 semaines")
            print("  Phase entretiens: 2-3 semaines")
            print("  Intégration: 3-4 semaines")
            print("  Total: 8-11 semaines")
        else:
            print("  Recherche complémentaire: 4-8 semaines")
            print("  Process complet: 10-15 semaines")

        print("\n" + "=" * 80)
        print("✅ ANALYSE DE RECRUTEMENT FRANÇAIS TERMINÉE!")
        print("💾 Données disponibles dans les variables de retour")
        print("=" * 80)

        return {
            'rfp_data': rfp_data,
            'top_candidates': top_candidates,
            'all_candidates': analyzed_candidates,
            'market_data': market_data,
            'final_report': final_report,
            'recommendation': recommendation
        }

    except Exception as e:
        print(f"❌ Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

class AnalyseurCandidatsFrancais:
    """Analyseur de candidats optimisé pour le contexte français"""

    def __init__(self, agent_gemini: AgentGeminiFrancais):
        self.gemini = agent_gemini

        # Variantes françaises pour matching
        self.variantes_francaises = {
            'python': ['python', 'py'],
            'javascript': ['javascript', 'js', 'node'],
            'machine learning': ['machine learning', 'ml', 'apprentissage automatique'],
            'data science': ['data science', 'science des données'],
            'gestion de projet': ['gestion de projet', 'chef de projet', 'project management'],
            'développement web': ['développement web', 'dev web', 'web development'],
            'rgpd': ['rgpd', 'gdpr', 'protection des données'],
            'cybersécurité': ['cybersécurité', 'sécurité informatique', 'cyber sécurité']
        }

        # Tarifs français (base annuelle en EUR)
        self.tarifs_francais = {
            'CDI': 42000,
            'CDD': 45000,
            'Expert': 75000,
            'Freelance': 58000,
            'Stage': 12000,
            'Alternance': 18000
        }

    def analyser_candidat(self, candidat_data: dict, rfp: RFPFrancais) -> ProfilCandidat:
        """Analyse complète d'un candidat"""

        texte_cv = candidat_data.get('resume_text', '').lower()

        # Extraction compétences avec matching français
        competences_trouvees = self._extraire_competences_candidat(texte_cv, rfp.competences_obligatoires + rfp.competences_souhaitees)

        # Extraction certifications
        certifications = self._extraire_certifications_candidat(texte_cv, rfp.certifications_requises)

        # Extraction expérience
        experience_ans = self._extraire_experience_candidat(texte_cv)

        # Calcul scores
        competences_obligatoires_trouvees = [c for c in competences_trouvees if c in rfp.competences_obligatoires]
        couverture_obligatoire = len(competences_obligatoires_trouvees) / max(len(rfp.competences_obligatoires), 1)

        competences_souhaitees_trouvees = [c for c in competences_trouvees if c in rfp.competences_souhaitees]
        couverture_souhaitee = len(competences_souhaitees_trouvees) / max(len(rfp.competences_souhaitees), 1)

        match_certifications = any(cert in rfp.certifications_requises for cert in certifications)
        match_experience = experience_ans >= rfp.experience_min_ans

        # Bonus contexte français
        bonus_francais = 0.1 if any(mot in texte_cv for mot in ['france', 'français', 'rgpd', 'cnil']) else 0

        # Score global
        score_match = min(
            couverture_obligatoire * 0.5 +
            (1.0 if match_experience else max(0.3, experience_ans / max(rfp.experience_min_ans, 1) * 0.7)) * 0.3 +
            couverture_souhaitee * 0.1 +
            (0.1 if match_certifications else 0) +
            bonus_francais,
            1.0
        )

        # Recommandation contrat et coût
        contrat, cout = self._recommander_contrat_cout(score_match, experience_ans, rfp.types_contrat)

        # Analyse forces/lacunes
        forces, lacunes = self._analyser_forces_lacunes(
            competences_obligatoires_trouvees, competences_souhaitees_trouvees,
            certifications, experience_ans, rfp.experience_min_ans
        )

        # Évaluation risque
        niveau_risque = self._evaluer_risque(score_match, couverture_obligatoire, match_certifications, match_experience)

        return ProfilCandidat(
            id=candidat_data.get('id', 0),
            categorie=candidat_data.get('category', 'Inconnu'),
            texte_cv=candidat_data.get('resume_text', ''),
            competences_trouvees=competences_trouvees,
            certifications=certifications,
            experience_ans=experience_ans,
            score_match=score_match,
            couverture_obligatoire=couverture_obligatoire,
            couverture_souhaitee=couverture_souhaitee,
            match_certifications=match_certifications,
            match_experience=match_experience,
            contrat_recommande=contrat,
            cout_estime=cout,
            forces=forces,
            lacunes=lacunes,
            niveau_risque=niveau_risque,
            axes_entretien=[]
        )

    def ameliorer_avec_gemini(self, candidat: ProfilCandidat, rfp: RFPFrancais) -> ProfilCandidat:
        """Améliore l'analyse avec Gemini"""

        try:
            # Préparer données pour Gemini
            donnees_candidat = {
                'categorie': candidat.categorie,
                'experience_ans': candidat.experience_ans,
                'competences_trouvees': candidat.competences_trouvees,
                'score_match': candidat.score_match,
                'texte_cv': candidat.texte_cv
            }

            donnees_rfp = {
                'titre': rfp.titre,
                'competences_obligatoires': rfp.competences_obligatoires,
                'experience_min_ans': rfp.experience_min_ans,
                'secteur': rfp.secteur
            }

            # Analyse Gemini
            analyse_gemini = self.gemini.analyser_candidat_francais(donnees_candidat, donnees_rfp)

            # Mise à jour du profil
            candidat.adequation_technique = analyse_gemini['adequation_technique']
            candidat.pertinence_experience = analyse_gemini['pertinence_experience']
            candidat.recommandation_gemini = analyse_gemini['recommandation']
            candidat.axes_entretien = analyse_gemini['axes_entretien']
            candidat.besoins_integration = analyse_gemini['besoins_integration']

            # Mise à jour forces/lacunes avec Gemini
            if analyse_gemini['forces']:
                candidat.forces = analyse_gemini['forces']
            if analyse_gemini['points_attention']:
                candidat.lacunes = analyse_gemini['points_attention']

        except Exception as e:
            print(f"Attention: Amélioration Gemini échouée: {e}")

        return candidat

    def _extraire_competences_candidat(self, texte_cv: str, competences_recherchees: List[str]) -> List[str]:
        """Extrait les compétences avec matching français"""
        competences_trouvees = []

        for competence in competences_recherchees:
            if self._matcher_competence_francaise(competence.lower(), texte_cv):
                competences_trouvees.append(competence)

        return competences_trouvees

    def _matcher_competence_francaise(self, competence: str, texte_cv: str) -> bool:
        """Matching de compétence avec variantes françaises"""

        # Match direct
        if competence in texte_cv:
            return True

        # Variantes françaises
        variantes = self.variantes_francaises.get(competence, [competence])
        return any(variante in texte_cv for variante in variantes)

    def _extraire_certifications_candidat(self, texte_cv: str, certifications_recherchees: List[str]) -> List[str]:
        """Extrait les certifications"""
        certifications_trouvees = []

        for cert in certifications_recherchees:
            if cert.lower() in texte_cv:
                certifications_trouvees.append(cert)

        return certifications_trouvees

    def _extraire_experience_candidat(self, texte_cv: str) -> int:
        """Extrait l'expérience avec patterns français"""
        patterns = [
            r'(\d+)\s*(?:ans?|années?)\s*(?:d[\'e]\s*)?(?:expériences?)',
            r'(\d+)\+\s*(?:ans?|années?)',
            r'depuis\s*(\d+)\s*(?:ans?|années?)'
        ]

        annees = []
        for pattern in patterns:
            matches = re.findall(pattern, texte_cv)
            annees.extend([int(m) for m in matches if m.isdigit()])

        return max(annees) if annees else 0

    def _recommander_contrat_cout(self, score_match: float, experience: int, contrats_disponibles: List[str]) -> Tuple[str, int]:
        """Recommande contrat et coût français"""

        # Multiplicateurs
        mult_experience = 1 + (experience * 0.045)  # 4.5% par an
        mult_match = 0.8 + (score_match * 0.4)     # 80-120%

        # Choix contrat
        if score_match >= 0.8 and experience >= 5 and 'Expert' in contrats_disponibles:
            type_contrat = 'Expert'
        elif score_match >= 0.7 and 'CDI' in contrats_disponibles:
            type_contrat = 'CDI'
        elif score_match >= 0.5 and 'CDD' in contrats_disponibles:
            type_contrat = 'CDD'
        elif 'Freelance' in contrats_disponibles:
            type_contrat = 'Freelance'
        else:
            type_contrat = contrats_disponibles[0] if contrats_disponibles else 'CDI'

        # Calcul coût
        cout_base = self.tarifs_francais.get(type_contrat, 42000)
        cout_estime = int(cout_base * mult_experience * mult_match)

        return type_contrat, cout_estime

    def _analyser_forces_lacunes(self, comp_obligatoires: List[str], comp_souhaitees: List[str],
                                certifications: List[str], experience: int, exp_requise: int) -> Tuple[List[str], List[str]]:
        """Analyse forces et lacunes"""

        forces = []
        lacunes = []

        # Forces
        if len(comp_obligatoires) > 0:
            forces.append(f"Maîtrise de {len(comp_obligatoires)} compétences clés")

        if certifications:
            forces.append(f"Certifications pertinentes: {', '.join(certifications[:2])}")

        if experience >= exp_requise:
            forces.append(f"Expérience suffisante ({experience} ans)")

        if len(comp_souhaitees) > 0:
            forces.append(f"Compétences bonus: {', '.join(comp_souhaitees[:2])}")

        # Lacunes
        if len(comp_obligatoires) == 0:
            lacunes.append("Aucune compétence obligatoire identifiée")

        if not certifications:
            lacunes.append("Pas de certifications trouvées")

        if experience < exp_requise:
            lacunes.append(f"Expérience insuffisante ({experience}/{exp_requise} ans)")

        return forces[:3], lacunes[:3]

    def _evaluer_risque(self, score_match: float, couverture_obligatoire: float,
                       match_certif: bool, match_exp: bool) -> str:
        """Évalue le niveau de risque"""

        facteurs_risque = 0

        if score_match < 0.5:
            facteurs_risque += 2
        elif score_match < 0.7:
            facteurs_risque += 1

        if couverture_obligatoire < 0.5:
            facteurs_risque += 2

        if not match_certif:
            facteurs_risque += 1

        if not match_exp:
            facteurs_risque += 1

        if facteurs_risque == 0:
            return "Faible"
        elif facteurs_risque <= 2:
            return "Moyen"
        elif facteurs_risque <= 4:
            return "Élevé"
        else:
            return "Très élevé"

print("✅ Analyseur Candidats Français prêt")

class SystemeRecrutementFrancais:
    """Système complet de recrutement français avec Gemini"""

    def __init__(self, modele_gemini: str = "google/gemma-2b-it"):
        print("🚀 Initialisation du Système de Recrutement Français")
        print("=" * 55)

        self.parseur_rfp = ParseurRFPFrancais()
        self.agent_gemini = AgentGeminiFrancais(modele_gemini)
        self.analyseur_candidats = AnalyseurCandidatsFrancais(self.agent_gemini)

        print("✅ Système initialisé avec succès")

    def analyser_recrutement_complet(self, chemin_pdf: str, chemin_csv: str) -> Dict:
        """Analyse complète de recrutement français"""

        resultats = {
            'rfp': None,
            'candidats_top': [],
            'tous_candidats': [],
            'donnees_marche': {},
            'rapport_executif': "",
            'recommandation': "",
            'timeline': "",
            'budget': (0, 0)
        }

        try:
            # 1. Analyse RFP
            print("\n📄 ANALYSE DU RFP FRANÇAIS")
            print("-" * 35)

            rfp = self.parseur_rfp.analyser_rfp_complet(chemin_pdf)
            print(f"✅ RFP analysé - Confiance: {rfp.score_confiance:.1%}")
            print(f"   Titre: {rfp.titre}")
            print(f"   Entreprise: {rfp.entreprise}")
            print(f"   Secteur: {rfp.secteur}")
            print(f"   Compétences trouvées: {len(rfp.competences_obligatoires)}")

            # Amélioration Gemini du RFP
            try:
                donnees_rfp = {
                    'titre': rfp.titre,
                    'competences_obligatoires': rfp.competences_obligatoires,
                    'competences_souhaitees': rfp.competences_souhaitees,
                    'experience_min_ans': rfp.experience_min_ans,
                    'certifications_requises': rfp.certifications_requises
                }

                analyse_gemini_rfp = self.agent_gemini.analyser_rfp_francais(rfp.texte_brut, donnees_rfp)

                rfp.niveau_poste = analyse_gemini_rfp['niveau_poste']
                rfp.type_role = analyse_gemini_rfp['type_role']

                # Ajout compétences suggérées par Gemini
                if analyse_gemini_rfp['competences_supplementaires']:
                    rfp.competences_obligatoires.extend(analyse_gemini_rfp['competences_supplementaires'][:3])
                    rfp.competences_obligatoires = list(set(rfp.competences_obligatoires))

                print(f"🤖 Amélioration Gemini - Niveau: {rfp.niveau_poste}, Type: {rfp.type_role}")

            except Exception as e:
                print(f"   Attention: Amélioration Gemini RFP échouée: {e}")

            resultats['rfp'] = rfp

            # 2. Chargement candidats
            print(f"\n📊 CHARGEMENT DES CANDIDATS")
            print("-" * 30)

            df = pd.read_csv(chemin_csv)
            candidats_data = []

            for idx, row in df.iterrows():
                candidats_data.append({
                    'id': idx,
                    'category': row['Category'],
                    'resume_text': row['Resume']
                })

            print(f"✅ {len(candidats_data)} candidats chargés")

            # 3. Analyse candidats
            print(f"\n🔍 ANALYSE DES CANDIDATS")
            print("-" * 25)

            candidats_analyses = []

            for i, candidat_data in enumerate(candidats_data):
                if i % 50 == 0:
                    print(f"   Traité {i}/{len(candidats_data)} candidats...")

                # Analyse de base
                profil = self.analyseur_candidats.analyser_candidat(candidat_data, rfp)
                candidats_analyses.append(profil)

            print(f"✅ Analyse de base terminée")

            # Tri par score
            candidats_analyses.sort(key=lambda x: x.score_match, reverse=True)

            # 4. Amélioration Gemini pour les top candidats
            print(f"\n🤖 AMÉLIORATION GEMINI TOP CANDIDATS")
            print("-" * 35)

            candidats_prometteurs = [c for c in candidats_analyses if c.score_match >= 0.4][:20]

            for i, candidat in enumerate(candidats_prometteurs):
                print(f"   Gemini {i+1}/{len(candidats_prometteurs)}: Candidat #{candidat.id}")
                try:
                    candidat = self.analyseur_candidats.ameliorer_avec_gemini(candidat, rfp)
                except Exception as e:
                    print(f"     Attention: Échec Gemini pour candidat {candidat.id}")

            print(f"✅ Amélioration Gemini terminée")

            # Re-tri après Gemini
            candidats_analyses.sort(key=lambda x: x.score_match, reverse=True)
            candidats_top = candidats_analyses[:15]

            resultats['candidats_top'] = candidats_top
            resultats['tous_candidats'] = candidats_analyses

            # 5. Génération données marché
            donnees_marche = self._generer_donnees_marche(candidats_analyses)
            resultats['donnees_marche'] = donnees_marche

            # 6. Génération rapport exécutif
            print(f"\n📋 GÉNÉRATION RAPPORT EXÉCUTIF")
            print("-" * 30)


            rapport_executif = self.agent_gemini.generer_rapport_executif(
                    candidats_top, donnees_rfp, donnees_marche
                )

                # Vérifier que le rapport n'est pas vide
            if not rapport_executif or len(rapport_executif.strip()) < 50:
                    print("⚠️  Rapport Gemini minimal, génération d'un rapport de base")
                    rapport_executif = "didn't work"

            resultats['rapport_executif'] = rapport_executif
            print("✅ Rapport exécutif généré")


            # 7. Recommandations finales
            meilleur_score = candidats_top[0].score_match if candidats_top else 0
            excellents = len([c for c in candidats_analyses if c.score_match >= 0.8])

            if meilleur_score >= 0.8 and excellents >= 2:
                resultats['recommandation'] = "EMBAUCHER"
                resultats['timeline'] = "2-4 semaines"
            elif meilleur_score >= 0.6:
                resultats['recommandation'] = "ÉVALUER"
                resultats['timeline'] = "4-6 semaines"
            else:
                resultats['recommandation'] = "ÉLARGIR RECHERCHE"
                resultats['timeline'] = "6-10 semaines"

            # Budget
            if candidats_top:
                couts = [c.cout_estime for c in candidats_top[:5]]
                resultats['budget'] = (min(couts), max(couts))

            return resultats

        except Exception as e:
            print(f"❌ Erreur lors de l'analyse: {e}")
            import traceback
            traceback.print_exc()
            return resultats

    def _generer_donnees_marche(self, candidats: List[ProfilCandidat]) -> Dict:
        """Génère les données d'analyse de marché"""

        categories = [c.categorie for c in candidats]
        scores = [c.score_match for c in candidats]
        experiences = [c.experience_ans for c in candidats]

        return {
            'total_analyses': len(candidats),
            'score_moyen': np.mean(scores),
            'avec_certifications': len([c for c in candidats if c.match_certifications]),
            'categories_top': dict(Counter(categories).most_common(5)),
            'distribution_experience': {
                'junior_0_2': len([e for e in experiences if 0 <= e <= 2]),
                'confirme_3_5': len([e for e in experiences if 3 <= e <= 5]),
                'senior_6_10': len([e for e in experiences if 6 <= e <= 10]),
                'expert_10_plus': len([e for e in experiences if e > 10])
            },
            'distribution_scores': {
                'excellent_80_plus': len([s for s in scores if s >= 0.8]),
                'bon_60_79': len([s for s in scores if 0.6 <= s < 0.8]),
                'moyen_40_59': len([s for s in scores if 0.4 <= s < 0.6]),
                'faible_moins_40': len([s for s in scores if s < 0.4])
            }
        }

    def afficher_resultats(self, resultats: Dict):
        """Affiche les résultats d'analyse"""

        if not resultats or not resultats['rfp']:
            print("❌ Aucun résultat à afficher")
            return

        rfp = resultats['rfp']
        candidats_top = resultats['candidats_top']
        donnees_marche = resultats['donnees_marche']

        print("\n" + "=" * 80)
        print("🇫🇷 RÉSULTATS ANALYSE DE RECRUTEMENT FRANÇAIS")
        print("=" * 80)

        # RFP
        print(f"\n📄 ANALYSE RFP")
        print("-" * 20)
        print(f"Poste: {rfp.titre}")
        print(f"Entreprise: {rfp.entreprise}")
        print(f"Secteur: {rfp.secteur}")
        print(f"Niveau: {rfp.niveau_poste}")
        print(f"Localisation: {rfp.localisation}")
        print(f"Expérience requise: {rfp.experience_min_ans} ans")
        print(f"Compétences clés: {', '.join(rfp.competences_obligatoires[:6])}")

        # Top candidats
        print(f"\n🏆 TOP CANDIDATS")
        print("-" * 15)

        for i, candidat in enumerate(candidats_top[:8], 1):
            print(f"\n{i}. Candidat #{candidat.id} ({candidat.categorie})")
            print(f"   Score: {candidat.score_match:.1%}")
            print(f"   Expérience: {candidat.experience_ans} ans")
            print(f"   Contrat: {candidat.contrat_recommande}")
            print(f"   Coût: {candidat.cout_estime:,} €/an")
            print(f"   Risque: {candidat.niveau_risque}")

            if candidat.recommandation_gemini:
                print(f"   Gemini: {candidat.recommandation_gemini}")
                if candidat.adequation_technique > 0:
                    print(f"   Technique: {candidat.adequation_technique}/10")

            if candidat.forces:
                print(f"   Forces: {', '.join(candidat.forces[:2])}")

        # Marché
        print(f"\n📊 ANALYSE MARCHÉ")
        print("-" * 15)
        print(f"Total analysé: {donnees_marche['total_analyses']}")
        print(f"Score moyen: {donnees_marche['score_moyen']:.1%}")
        print(f"Avec certifications: {donnees_marche['avec_certifications']}")

        dist_scores = donnees_marche['distribution_scores']
        print(f"\nDistribution qualité:")
        print(f"  Excellent (80%+): {dist_scores['excellent_80_plus']}")
        print(f"  Bon (60-79%): {dist_scores['bon_60_79']}")
        print(f"  Moyen (40-59%): {dist_scores['moyen_40_59']}")
        print(f"  Faible (<40%): {dist_scores['faible_moins_40']}")

        # Recommandation
        print(f"\n🎯 RECOMMANDATION")
        print("-" * 15)
        print(f"Decision: {resultats['recommandation']}")
        print(f"Timeline: {resultats['timeline']}")
        if resultats['budget'][0] > 0:
            print(f"Budget: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} €")

        # Rapport Gemini
        if resultats['rapport_executif']:
            print(f"\n🤖 RAPPORT GEMINI")
            print("-" * 15)
            print(resultats['rapport_executif'])

        print("\n" + "=" * 80)

    def sauvegarder_resultats(self, resultats: Dict, dossier_sortie: str = "resultats_recrutement"):
        """Sauvegarde les résultats avec génération PDF structuré"""

        import os
        from datetime import datetime

        os.makedirs(dossier_sortie, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        try:
            # JSON principal (existant)
            donnees_principales = {
                'rfp': {
                    'titre': resultats['rfp'].titre,
                    'entreprise': resultats['rfp'].entreprise,
                    'secteur': resultats['rfp'].secteur,
                    'competences_obligatoires': resultats['rfp'].competences_obligatoires,
                    'experience_min_ans': resultats['rfp'].experience_min_ans,
                    'niveau_poste': resultats['rfp'].niveau_poste
                },
                'top_candidats': [
                    {
                        'id': c.id,
                        'categorie': c.categorie,
                        'score_match': c.score_match,
                        'experience_ans': c.experience_ans,
                        'contrat_recommande': c.contrat_recommande,
                        'cout_estime': c.cout_estime,
                        'niveau_risque': c.niveau_risque,
                        'recommandation_gemini': c.recommandation_gemini,
                        'adequation_technique': c.adequation_technique,
                        'pertinence_experience': c.pertinence_experience,
                        'forces': c.forces,
                        'lacunes': c.lacunes,
                        'axes_entretien': c.axes_entretien or [],
                        'besoins_integration': c.besoins_integration or []
                    } for c in resultats['candidats_top'][:10]
                ],
                'donnees_marche': resultats['donnees_marche'],
                'recommandation': resultats['recommandation'],
                'timeline': resultats['timeline'],
                'budget': resultats['budget'],
                'rapport_gemini': resultats['rapport_executif'],  # S'assurer que le rapport Gemini est inclus
                'timestamp': timestamp
            }

            with open(f"{dossier_sortie}/analyse_recrutement_{timestamp}.json", 'w', encoding='utf-8') as f:
                json.dump(donnees_principales, f, indent=2, ensure_ascii=False, default=str)

            # NOUVEAU: Génération PDF structuré
            pdf_file = self._generer_pdf_structure(resultats, dossier_sortie, timestamp)

            # Rapport exécutif TXT (existant)
            with open(f"{dossier_sortie}/rapport_executif_{timestamp}.txt", 'w', encoding='utf-8') as f:
                f.write("RAPPORT EXÉCUTIF - ANALYSE DE RECRUTEMENT\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"Généré le: {datetime.now().strftime('%d/%m/%Y à %H:%M')}\n\n")
                f.write(f"POSTE: {resultats['rfp'].titre}\n")
                f.write(f"ENTREPRISE: {resultats['rfp'].entreprise}\n\n")
                f.write("RAPPORT GEMINI:\n")
                f.write("-" * 20 + "\n")
                f.write(resultats['rapport_executif'])

            # Analyse complète TXT (existant - gardé pour compatibilité)
            with open(f"{dossier_sortie}/analyse_complete_{timestamp}.txt", 'w', encoding='utf-8') as f:
                f.write("🇫🇷 ANALYSE COMPLÈTE DE RECRUTEMENT FRANÇAIS\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"📅 Généré le: {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}\n\n")

                # Section RFP
                f.write("📄 ANALYSE DU RFP\n")
                f.write("-" * 25 + "\n")
                f.write(f"Titre du poste: {resultats['rfp'].titre}\n")
                f.write(f"Entreprise: {resultats['rfp'].entreprise}\n")
                f.write(f"Secteur d'activité: {resultats['rfp'].secteur}\n")
                f.write(f"Niveau du poste: {resultats['rfp'].niveau_poste}\n")
                f.write(f"Type de rôle: {resultats['rfp'].type_role}\n")
                f.write(f"Localisation: {resultats['rfp'].localisation}\n")
                f.write(f"Expérience requise: {resultats['rfp'].experience_min_ans} ans minimum\n")
                f.write(f"Délais: {resultats['rfp'].delais}\n")
                f.write(f"Budget: {resultats['rfp'].budget}\n")
                f.write(f"Score de confiance extraction: {resultats['rfp'].score_confiance:.1%}\n\n")

                f.write(f"Compétences obligatoires ({len(resultats['rfp'].competences_obligatoires)}):\n")
                for i, comp in enumerate(resultats['rfp'].competences_obligatoires, 1):
                    f.write(f"  {i:2d}. {comp}\n")
                f.write("\n")

                f.write(f"Compétences souhaitées ({len(resultats['rfp'].competences_souhaitees)}):\n")
                for i, comp in enumerate(resultats['rfp'].competences_souhaitees, 1):
                    f.write(f"  {i:2d}. {comp}\n")
                f.write("\n")

                if resultats['rfp'].certifications_requises:
                    f.write(f"Certifications requises:\n")
                    for i, cert in enumerate(resultats['rfp'].certifications_requises, 1):
                        f.write(f"  {i}. {cert}\n")
                    f.write("\n")

                # Section Candidats Top
                f.write("🏆 TOP CANDIDATS ANALYSÉS\n")
                f.write("-" * 30 + "\n")

                for i, candidat in enumerate(resultats['candidats_top'][:10], 1):
                    f.write(f"{i:2d}. CANDIDAT #{candidat.id:3d} | {candidat.categorie}\n")
                    f.write(f"    Score de correspondance: {candidat.score_match:.1%}\n")
                    f.write(f"    Expérience: {candidat.experience_ans} ans\n")
                    f.write(f"    Couverture compétences obligatoires: {candidat.couverture_obligatoire:.1%}\n")
                    f.write(f"    Couverture compétences souhaitées: {candidat.couverture_souhaitee:.1%}\n")
                    f.write(f"    Certifications: {'✓' if candidat.match_certifications else '✗'}\n")
                    f.write(f"    Expérience suffisante: {'✓' if candidat.match_experience else '✗'}\n")
                    f.write(f"    Contrat recommandé: {candidat.contrat_recommande}\n")
                    f.write(f"    Coût estimé: {candidat.cout_estime:,} €/an\n")
                    f.write(f"    Niveau de risque: {candidat.niveau_risque}\n")

                    if candidat.recommandation_gemini:
                        f.write(f"    Recommandation Gemini: {candidat.recommandation_gemini}\n")
                        if candidat.adequation_technique > 0:
                            f.write(f"    Adéquation technique: {candidat.adequation_technique}/10\n")
                        if candidat.pertinence_experience > 0:
                            f.write(f"    Pertinence expérience: {candidat.pertinence_experience}/10\n")

                    if candidat.forces:
                        f.write(f"    Forces principales:\n")
                        for force in candidat.forces:
                            f.write(f"      • {force}\n")

                    if candidat.lacunes:
                        f.write(f"    Points d'attention:\n")
                        for lacune in candidat.lacunes:
                            f.write(f"      • {lacune}\n")

                    if candidat.axes_entretien:
                        f.write(f"    Axes d'entretien suggérés:\n")
                        for axe in candidat.axes_entretien:
                            f.write(f"      • {axe}\n")

                    if candidat.besoins_integration:
                        f.write(f"    Besoins d'intégration:\n")
                        for besoin in candidat.besoins_integration:
                            f.write(f"      • {besoin}\n")

                    f.write(f"    Compétences trouvées: {', '.join(candidat.competences_trouvees[:8])}")
                    if len(candidat.competences_trouvees) > 8:
                        f.write(f" (+{len(candidat.competences_trouvees)-8} autres)")
                    f.write("\n\n")

                # Section Analyse Marché
                f.write("📊 ANALYSE DU MARCHÉ\n")
                f.write("-" * 25 + "\n")
                dm = resultats['donnees_marche']
                f.write(f"Total candidats analysés: {dm['total_analyses']}\n")
                f.write(f"Score moyen de correspondance: {dm['score_moyen']:.1%}\n")
                f.write(f"Candidats avec certifications: {dm['avec_certifications']}\n\n")

                f.write("Distribution par niveau d'expérience:\n")
                exp_dist = dm['distribution_experience']
                f.write(f"  • Junior (0-2 ans): {exp_dist['junior_0_2']} candidats\n")
                f.write(f"  • Confirmé (3-5 ans): {exp_dist['confirme_3_5']} candidats\n")
                f.write(f"  • Senior (6-10 ans): {exp_dist['senior_6_10']} candidats\n")
                f.write(f"  • Expert (10+ ans): {exp_dist['expert_10_plus']} candidats\n\n")

                f.write("Distribution par qualité de correspondance:\n")
                score_dist = dm['distribution_scores']
                f.write(f"  • Excellent (80%+): {score_dist['excellent_80_plus']} candidats\n")
                f.write(f"  • Bon (60-79%): {score_dist['bon_60_79']} candidats\n")
                f.write(f"  • Moyen (40-59%): {score_dist['moyen_40_59']} candidats\n")
                f.write(f"  • Faible (<40%): {score_dist['faible_moins_40']} candidats\n\n")

                f.write("Top 5 catégories de candidats:\n")
                for i, (categorie, nombre) in enumerate(dm['categories_top'].items(), 1):
                    if i <= 5:
                        f.write(f"  {i}. {categorie}: {nombre} candidats\n")
                f.write("\n")

                # Section Recommandations
                f.write("🎯 RECOMMANDATIONS STRATÉGIQUES\n")
                f.write("-" * 35 + "\n")
                f.write(f"Décision recommandée: {resultats['recommandation']}\n")
                f.write(f"Timeline estimée: {resultats['timeline']}\n")
                if resultats['budget'][0] > 0:
                    f.write(f"Fourchette budgétaire: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} € / an\n")
                f.write("\n")

                # Justification de la recommandation
                if resultats['recommandation'] == "EMBAUCHER":
                    f.write("Justification: Plusieurs candidats excellents identifiés avec un fort potentiel.\n")
                    f.write("Actions recommandées:\n")
                    f.write("  • Planifier les entretiens avec les 3 meilleurs candidats\n")
                    f.write("  • Préparer les évaluations techniques spécifiques\n")
                    f.write("  • Vérifier les références et certifications\n")
                    f.write("  • Négocier les conditions contractuelles\n")
                elif resultats['recommandation'] == "ÉVALUER":
                    f.write("Justification: Candidats prometteurs nécessitant une évaluation approfondie.\n")
                    f.write("Actions recommandées:\n")
                    f.write("  • Conduire des entretiens techniques détaillés\n")
                    f.write("  • Évaluer les besoins de formation\n")
                    f.write("  • Considérer une période d'essai\n")
                    f.write("  • Élargir la recherche si nécessaire\n")
                else:
                    f.write("Justification: Pool actuel insuffisant pour les exigences du poste.\n")
                    f.write("Actions recommandées:\n")
                    f.write("  • Réviser les critères de sélection\n")
                    f.write("  • Élargir les sources de recrutement\n")
                    f.write("  • Considérer des cabinets spécialisés\n")
                    f.write("  • Évaluer les options de formation interne\n")
                f.write("\n")

                # Section Rapport Gemini
                f.write("🤖 RAPPORT EXÉCUTIF GEMINI\n")
                f.write("-" * 30 + "\n")
                f.write(resultats['rapport_executif'])
                f.write("\n\n")

                # Footer
                f.write("=" * 60 + "\n")
                f.write("Rapport généré par le Système de Recrutement Français avec Gemini\n")
                f.write(f"Fichier: analyse_complete_{timestamp}.txt\n")
                f.write("=" * 60 + "\n")

            # CSV candidats
            candidats_df = pd.DataFrame([
                {
                    'ID': c.id,
                    'Catégorie': c.categorie,
                    'Score_Match': f"{c.score_match:.1%}",
                    'Expérience_Ans': c.experience_ans,
                    'Contrat_Recommandé': c.contrat_recommande,
                    'Coût_Estimé_EUR': c.cout_estime,
                    'Niveau_Risque': c.niveau_risque,
                    'Recommandation_Gemini': c.recommandation_gemini,
                    'Adéquation_Technique': f"{c.adequation_technique}/10" if c.adequation_technique > 0 else "N/A",
                    'Pertinence_Expérience': f"{c.pertinence_experience}/10" if c.pertinence_experience > 0 else "N/A",
                    'Forces': '; '.join(c.forces),
                    'Lacunes': '; '.join(c.lacunes),
                    'Axes_Entretien': '; '.join(c.axes_entretien or []),
                    'Besoins_Intégration': '; '.join(c.besoins_integration or [])
                } for c in resultats['candidats_top'][:20]
            ])

            candidats_df.to_csv(f"{dossier_sortie}/candidats_top_{timestamp}.csv",
                              index=False, encoding='utf-8')

            print(f"✅ Résultats sauvegardés dans: {dossier_sortie}/")
            print(f"   📄 Analyse complète: analyse_recrutement_{timestamp}.json")
            print(f"   📋 Rapport exécutif: rapport_executif_{timestamp}.txt")
            print(f"   📊 Top candidats: candidats_top_{timestamp}.csv")
            print(f"   📝 Analyse détaillée: analyse_complete_{timestamp}.txt")
            if pdf_file:
                print(f"   📑 Rapport PDF structuré: {pdf_file}")

            return f"{dossier_sortie}/analyse_recrutement_{timestamp}.json"

        except Exception as e:
            print(f"❌ Erreur sauvegarde: {e}")
            return None

    def _generer_pdf_structure(self, resultats: Dict, dossier_sortie: str, timestamp: str) -> str:
        """Génère un PDF structuré professionnel avec les résultats LLM"""

        try:
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY
            from datetime import datetime

            # Nom du fichier PDF
            pdf_filename = f"{dossier_sortie}/rapport_recrutement_{timestamp}.pdf"

            # Création du document
            doc = SimpleDocTemplate(pdf_filename, pagesize=A4,
                                  rightMargin=72, leftMargin=72,
                                  topMargin=72, bottomMargin=18)

            # Styles
            styles = getSampleStyleSheet()
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=18,
                textColor=colors.HexColor('#2E4057'),
                alignment=TA_CENTER,
                spaceAfter=30
            )

            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontSize=14,
                textColor=colors.HexColor('#048A81'),
                spaceBefore=20,
                spaceAfter=10
            )

            subheading_style = ParagraphStyle(
                'CustomSubHeading',
                parent=styles['Heading3'],
                fontSize=12,
                textColor=colors.HexColor('#2E4057'),
                spaceBefore=15,
                spaceAfter=8
            )

            normal_style = ParagraphStyle(
                'CustomNormal',
                parent=styles['Normal'],
                fontSize=10,
                alignment=TA_JUSTIFY,
                spaceAfter=6
            )

            # Contenu du PDF
            story = []

            # Page de titre
            story.append(Paragraph("RAPPORT D'ANALYSE DE RECRUTEMENT", title_style))
            story.append(Paragraph("Système de Recrutement Français avec IA", styles['Heading3']))
            story.append(Spacer(1, 30))

            # Informations générales
            story.append(Paragraph(f"<b>Poste analysé:</b> {resultats['rfp'].titre}", normal_style))
            story.append(Paragraph(f"<b>Entreprise:</b> {resultats['rfp'].entreprise}", normal_style))
            story.append(Paragraph(f"<b>Secteur:</b> {resultats['rfp'].secteur}", normal_style))
            story.append(Paragraph(f"<b>Date d'analyse:</b> {datetime.now().strftime('%d/%m/%Y à %H:%M')}", normal_style))
            story.append(Spacer(1, 30))

            # Résumé exécutif
            story.append(Paragraph("RÉSUMÉ EXÉCUTIF", heading_style))

            # Boîte de recommandation
            recommandation_color = colors.green if resultats['recommandation'] == "EMBAUCHER" else \
                                  colors.orange if resultats['recommandation'] == "ÉVALUER" else colors.red

            rec_data = [
                ['RECOMMANDATION', resultats['recommandation']],
                ['TIMELINE', resultats['timeline']],
                ['BUDGET ESTIMÉ', f"{resultats['budget'][0]:,} - {resultats['budget'][1]:,} €/an" if resultats['budget'][0] > 0 else "À définir"],
                ['CANDIDATS ANALYSÉS', str(resultats['donnees_marche']['total_analyses'])],
                ['CANDIDATS EXCELLENTS', str(resultats['donnees_marche']['distribution_scores']['excellent_80_plus'])]
            ]

            rec_table = Table(rec_data, colWidths=[2*inch, 3*inch])
            rec_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#048A81')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('BACKGROUND', (0, 1), (0, -1), colors.HexColor('#E8F4F8')),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(rec_table)
            story.append(Spacer(1, 20))

            # Analyse du RFP
            story.append(Paragraph("ANALYSE DU POSTE", heading_style))
            story.append(Paragraph(f"<b>Niveau requis:</b> {resultats['rfp'].niveau_poste}", normal_style))
            story.append(Paragraph(f"<b>Expérience minimum:</b> {resultats['rfp'].experience_min_ans} ans", normal_style))
            story.append(Paragraph(f"<b>Localisation:</b> {resultats['rfp'].localisation}", normal_style))

            # Compétences obligatoires
            story.append(Paragraph("Compétences obligatoires:", subheading_style))
            comp_text = ", ".join(resultats['rfp'].competences_obligatoires[:10])
            if len(resultats['rfp'].competences_obligatoires) > 10:
                comp_text += f" (et {len(resultats['rfp'].competences_obligatoires) - 10} autres)"
            story.append(Paragraph(comp_text, normal_style))
            story.append(Spacer(1, 15))

            # TOP CANDIDATS
            story.append(Paragraph("TOP CANDIDATS IDENTIFIÉS", heading_style))

            if resultats['candidats_top']:
                for i, candidat in enumerate(resultats['candidats_top'][:5], 1):
                    story.append(Paragraph(f"CANDIDAT #{candidat.id} - {candidat.categorie}", subheading_style))

                    # Tableau des métriques du candidat
                    candidat_data = [
                        ['Score de correspondance', f"{candidat.score_match:.1%}"],
                        ['Expérience', f"{candidat.experience_ans} ans"],
                        ['Contrat recommandé', candidat.contrat_recommande],
                        ['Coût estimé', f"{candidat.cout_estime:,} €/an"],
                        ['Niveau de risque', candidat.niveau_risque]
                    ]

                    # Ajouter les scores Gemini si disponibles
                    if candidat.adequation_technique > 0:
                        candidat_data.append(['Adéquation technique (Gemini)', f"{candidat.adequation_technique}/10"])
                    if candidat.pertinence_experience > 0:
                        candidat_data.append(['Pertinence expérience (Gemini)', f"{candidat.pertinence_experience}/10"])
                    if candidat.recommandation_gemini:
                        candidat_data.append(['Recommandation Gemini', candidat.recommandation_gemini])

                    candidat_table = Table(candidat_data, colWidths=[2.5*inch, 2.5*inch])
                    candidat_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#F0F8FF')),
                        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)
                    ]))
                    story.append(candidat_table)

                    # Forces et lacunes
                    if candidat.forces:
                        story.append(Paragraph("<b>Forces:</b>", normal_style))
                        for force in candidat.forces[:3]:
                            story.append(Paragraph(f"• {force}", normal_style))

                    if candidat.lacunes:
                        story.append(Paragraph("<b>Points d'attention:</b>", normal_style))
                        for lacune in candidat.lacunes[:3]:
                            story.append(Paragraph(f"• {lacune}", normal_style))

                    # Axes d'entretien Gemini
                    if candidat.axes_entretien:
                        story.append(Paragraph("<b>Axes d'entretien suggérés (Gemini):</b>", normal_style))
                        for axe in candidat.axes_entretien[:3]:
                            story.append(Paragraph(f"• {axe}", normal_style))

                    # Besoins d'intégration Gemini
                    if candidat.besoins_integration:
                        story.append(Paragraph("<b>Besoins d'intégration (Gemini):</b>", normal_style))
                        for besoin in candidat.besoins_integration[:3]:
                            story.append(Paragraph(f"• {besoin}", normal_style))

                    story.append(Spacer(1, 15))

            # Nouvelle page pour l'analyse de marché
            story.append(PageBreak())

            # ANALYSE DE MARCHÉ
            story.append(Paragraph("ANALYSE DU MARCHÉ", heading_style))

            dm = resultats['donnees_marche']

            # Tableau de distribution des scores
            score_dist = dm['distribution_scores']
            score_data = [
                ['Niveau de correspondance', 'Nombre de candidats', 'Pourcentage'],
                ['Excellent (80%+)', str(score_dist['excellent_80_plus']), f"{score_dist['excellent_80_plus']/dm['total_analyses']*100:.1f}%"],
                ['Bon (60-79%)', str(score_dist['bon_60_79']), f"{score_dist['bon_60_79']/dm['total_analyses']*100:.1f}%"],
                ['Moyen (40-59%)', str(score_dist['moyen_40_59']), f"{score_dist['moyen_40_59']/dm['total_analyses']*100:.1f}%"],
                ['Faible (<40%)', str(score_dist['faible_moins_40']), f"{score_dist['faible_moins_40']/dm['total_analyses']*100:.1f}%"]
            ]

            score_table = Table(score_data, colWidths=[2*inch, 1.5*inch, 1.5*inch])
            score_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E4057')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(score_table)
            story.append(Spacer(1, 20))

            # Distribution par expérience
            story.append(Paragraph("Distribution par niveau d'expérience:", subheading_style))
            exp_dist = dm['distribution_experience']
            exp_data = [
                ['Niveau d\'expérience', 'Nombre de candidats'],
                ['Junior (0-2 ans)', str(exp_dist['junior_0_2'])],
                ['Confirmé (3-5 ans)', str(exp_dist['confirme_3_5'])],
                ['Senior (6-10 ans)', str(exp_dist['senior_6_10'])],
                ['Expert (10+ ans)', str(exp_dist['expert_10_plus'])]
            ]

            exp_table = Table(exp_data, colWidths=[3*inch, 2*inch])
            exp_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#048A81')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(exp_table)
            story.append(Spacer(1, 20))

            # Top catégories
            story.append(Paragraph("Top 5 catégories de candidats:", subheading_style))
            cat_list = []
            for i, (categorie, nombre) in enumerate(list(dm['categories_top'].items())[:5], 1):
                cat_list.append(f"{i}. {categorie}: {nombre} candidats")
            story.append(Paragraph("<br/>".join(cat_list), normal_style))
            story.append(Spacer(1, 20))

            # RAPPORT GEMINI
            story.append(Paragraph("RAPPORT EXÉCUTIF GEMINI", heading_style))

            # Vérifier si le rapport Gemini existe et n'est pas vide
            rapport_gemini = resultats.get('rapport_executif', '')
            if rapport_gemini and rapport_gemini.strip() and "non disponible" not in rapport_gemini.lower():
                # Diviser le rapport en paragraphes pour un meilleur formatage
                paragraphes_gemini = rapport_gemini.split('\n\n')
                for paragraphe in paragraphes_gemini:
                    if paragraphe.strip():
                        # Identifier les titres (contiennent des majuscules ou des :)
                        if ':' in paragraphe or paragraphe.isupper() or paragraphe.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.')):
                            story.append(Paragraph(f"<b>{paragraphe.strip()}</b>", normal_style))
                        else:
                            story.append(Paragraph(paragraphe.strip(), normal_style))
                        story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("<i>Rapport Gemini non disponible - Analyse effectuée en mode de base.</i>", normal_style))
                story.append(Paragraph("L'analyse a été réalisée avec les algorithmes de base du système. "
                                     "Pour obtenir un rapport Gemini complet, configurez l'authentification "
                                     "Hugging Face ou utilisez un modèle alternatif.", normal_style))

            story.append(Spacer(1, 20))

            # RECOMMANDATIONS STRATÉGIQUES
            story.append(Paragraph("RECOMMANDATIONS STRATÉGIQUES", heading_style))

            # Actions recommandées selon la décision
            if resultats['recommandation'] == "EMBAUCHER":
                story.append(Paragraph("<b>Décision: PROCÉDER À L'EMBAUCHE</b>", subheading_style))
                story.append(Paragraph("Justification: Plusieurs candidats excellents identifiés avec un fort potentiel de réussite.", normal_style))
                actions = [
                    "Planifier les entretiens avec les 3 meilleurs candidats",
                    "Préparer des évaluations techniques spécifiques au poste",
                    "Vérifier les références et certifications des candidats sélectionnés",
                    "Négocier les conditions contractuelles et salariales",
                    "Organiser l'intégration et la formation d'accueil"
                ]
            elif resultats['recommandation'] == "ÉVALUER":
                story.append(Paragraph("<b>Décision: ÉVALUATION APPROFONDIE REQUISE</b>", subheading_style))
                story.append(Paragraph("Justification: Candidats prometteurs identifiés nécessitant une analyse plus poussée.", normal_style))
                actions = [
                    "Conduire des entretiens techniques détaillés",
                    "Évaluer les besoins de formation et d'accompagnement",
                    "Considérer une période d'essai ou un projet pilote",
                    "Élargir la recherche si les résultats ne sont pas concluants",
                    "Réviser les critères de sélection si nécessaire"
                ]
            else:
                story.append(Paragraph("<b>Décision: ÉLARGIR LA RECHERCHE</b>", subheading_style))
                story.append(Paragraph("Justification: Le pool actuel de candidats ne répond pas suffisamment aux exigences du poste.", normal_style))
                actions = [
                    "Réviser et ajuster les critères de sélection",
                    "Élargir les sources de recrutement (réseaux, cabinets spécialisés)",
                    "Considérer des profils en reconversion avec formation",
                    "Évaluer les possibilités de promotion interne",
                    "Revoir le budget et les conditions proposées"
                ]

            story.append(Paragraph("<b>Actions prioritaires:</b>", normal_style))
            for i, action in enumerate(actions, 1):
                story.append(Paragraph(f"{i}. {action}", normal_style))

            story.append(Spacer(1, 20))

            # ANALYSE FINANCIÈRE
            story.append(Paragraph("ANALYSE FINANCIÈRE", heading_style))

            if resultats['budget'][0] > 0:
                budget_data = [
                    ['Métrique', 'Valeur'],
                    ['Fourchette salariale', f"{resultats['budget'][0]:,} - {resultats['budget'][1]:,} €/an"],
                    ['Coût moyen estimé', f"{(resultats['budget'][0] + resultats['budget'][1]) // 2:,} €/an"],
                    ['Timeline de recrutement', resultats['timeline']]
                ]

                if resultats['candidats_top']:
                    meilleur_candidat = resultats['candidats_top'][0]
                    budget_data.append(['Meilleur candidat (coût)', f"{meilleur_candidat.cout_estime:,} €/an"])
                    budget_data.append(['Type de contrat suggéré', meilleur_candidat.contrat_recommande])

                budget_table = Table(budget_data, colWidths=[2.5*inch, 2.5*inch])
                budget_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E4057')),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                story.append(budget_table)
            else:
                story.append(Paragraph("Budget à définir selon les profils sélectionnés.", normal_style))

            story.append(Spacer(1, 20))

            # CONCLUSION ET PROCHAINES ÉTAPES
            story.append(Paragraph("CONCLUSION", heading_style))

            conclusion_text = f"""
            Cette analyse a permis d'évaluer {dm['total_analyses']} candidats pour le poste de {resultats['rfp'].titre}
            chez {resultats['rfp'].entreprise}. Le système a identifié {score_dist['excellent_80_plus']} candidats excellents
            et {score_dist['bon_60_79']} candidats de bon niveau.

            La recommandation principale est de <b>{resultats['recommandation']}</b> avec une timeline estimée de {resultats['timeline']}.

            Les analyses Gemini ont apporté une évaluation qualitative approfondie des candidats les plus prometteurs,
            incluant des recommandations spécifiques pour les entretiens et l'intégration.
            """

            story.append(Paragraph(conclusion_text, normal_style))
            story.append(Spacer(1, 20))

            # Footer avec métadonnées
            story.append(Spacer(1, 30))
            footer_style = ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=8,
                textColor=colors.grey,
                alignment=TA_CENTER
            )

            story.append(Paragraph("_" * 80, footer_style))
            story.append(Paragraph(f"Rapport généré le {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}", footer_style))
            story.append(Paragraph("Système de Recrutement Français avec Intelligence Artificielle", footer_style))
            story.append(Paragraph(f"Fichier: rapport_recrutement_{timestamp}.pdf", footer_style))

            # Génération du PDF
            doc.build(story)

            return f"rapport_recrutement_{timestamp}.pdf"

        except ImportError:
            print("⚠️  ReportLab non installé. Installation automatique...")
            try:
                import subprocess
                import sys
                subprocess.check_call([sys.executable, "-m", "pip", "install", "reportlab"])
                print("✅ ReportLab installé. Relancez la fonction.")
                return None
            except Exception as e:
                print(f"❌ Impossible d'installer ReportLab: {e}")
                print("💡 Installez manuellement avec: pip install reportlab")
                return None

        except Exception as e:
            print(f"❌ Erreur génération PDF: {e}")
            print("💡 Le PDF n'a pas pu être créé, mais les autres fichiers sont disponibles")
            return None


print("✅ Système de Recrutement Français complet prêt")

def main(chemin_rfp_pdf: str, chemin_dataset_csv: str = "UpdatedResumeDataSet.csv",
         modele_gemini: str = "google/gemma-2b-it", sauvegarder: bool = True):
    """
    Fonction principale d'analyse de recrutement français

    Args:
        chemin_rfp_pdf: Chemin vers le fichier PDF du RFP
        chemin_dataset_csv: Chemin vers le dataset de CVs (défaut: UpdatedResumeDataSet.csv)
        modele_gemini: Modèle Gemini à utiliser (défaut: google/gemma-2b-it)
        sauvegarder: Sauvegarder les résultats (défaut: True)

    Returns:
        Dict: Résultats complets de l'analyse
    """

    print("🇫🇷 SYSTÈME DE RECRUTEMENT FRANÇAIS AVEC GEMINI")
    print("=" * 55)
    print(f"📄 RFP: {chemin_rfp_pdf}")
    print(f"📊 Dataset: {chemin_dataset_csv}")
    print(f"🤖 Modèle: {modele_gemini}")
    print("=" * 55)

    try:
        # Vérification des fichiers
        import os
        if not os.path.exists(chemin_rfp_pdf):
            raise FileNotFoundError(f"Fichier RFP non trouvé: {chemin_rfp_pdf}")

        if not os.path.exists(chemin_dataset_csv):
            raise FileNotFoundError(f"Dataset non trouvé: {chemin_dataset_csv}")

        # Initialisation du système
        print("\n⚙️ INITIALISATION DU SYSTÈME")
        systeme = SystemeRecrutementFrancais(modele_gemini)

        # Analyse complète
        print("\n🔍 LANCEMENT DE L'ANALYSE COMPLÈTE")
        resultats = systeme.analyser_recrutement_complet(chemin_rfp_pdf, chemin_dataset_csv)

        if not resultats or not resultats['rfp']:
            print("❌ Échec de l'analyse")
            return None

        # Affichage des résultats
        systeme.afficher_resultats(resultats)

        # Sauvegarde
        if sauvegarder:
            print("\n💾 SAUVEGARDE DES RÉSULTATS")
            fichier_sauvegarde = systeme.sauvegarder_resultats(resultats)
            resultats['fichier_sauvegarde'] = fichier_sauvegarde

        # Résumé final
        print("\n🎉 ANALYSE TERMINÉE AVEC SUCCÈS!")
        print("=" * 40)

        candidats_top = resultats['candidats_top']
        if candidats_top:
            meilleur = candidats_top[0]
            print(f"🏆 Meilleur candidat: #{meilleur.id} ({meilleur.score_match:.1%})")
            print(f"💰 Budget estimé: {resultats['budget'][0]:,} - {resultats['budget'][1]:,} €")
            print(f"⏱️ Timeline: {resultats['timeline']}")
            print(f"🎯 Recommandation: {resultats['recommandation']}")

        print("=" * 40)

        return resultats

    except FileNotFoundError as e:
        print(f"❌ Erreur fichier: {e}")
        print("💡 Vérifiez les chemins des fichiers")
        return None

    except Exception as e:
        print(f"❌ Erreur inattendue: {e}")
        print("💡 Vérifiez les logs ci-dessus pour plus de détails")
        import traceback
        traceback.print_exc()
        return None

def analyser_rfp_simple(chemin_pdf: str):
    """Analyse simple d'un RFP pour prévisualisation (sans Gemini)"""

    print("🔍 ANALYSE RAPIDE DU RFP (MODE DE BASE)")
    print("-" * 40)

    try:
        parseur = ParseurRFPFrancais()
        rfp = parseur.analyser_rfp_complet(chemin_pdf)

        print(f"✅ RFP analysé avec succès")
        print(f"   Titre: {rfp.titre}")
        print(f"   Entreprise: {rfp.entreprise}")
        print(f"   Secteur: {rfp.secteur}")
        print(f"   Expérience requise: {rfp.experience_min_ans} ans")
        print(f"   Compétences obligatoires ({len(rfp.competences_obligatoires)}):")

        for i, comp in enumerate(rfp.competences_obligatoires[:8], 1):
            print(f"      {i}. {comp}")

        if len(rfp.competences_obligatoires) > 8:
            print(f"      ... et {len(rfp.competences_obligatoires) - 8} autres")

        print(f"   Score de confiance: {rfp.score_confiance:.1%}")

        return rfp

    except Exception as e:
        print(f"❌ Erreur: {e}")
        return None

def lister_modeles_gemini():
    """Liste les modèles Gemini disponibles"""

    modeles = {
        "google/gemma-2b-it": {
            "taille": "2B paramètres",
            "vitesse": "🚀 Rapide",
            "qualite": "⭐⭐⭐ Bonne",
            "usage": "Idéal pour tests et analyses rapides"
        },
        "google/gemma-7b-it": {
            "taille": "7B paramètres",
            "vitesse": "🐌 Plus lent",
            "qualite": "⭐⭐⭐⭐⭐ Excellente",
            "usage": "Recommandé pour analyses finales"
        }
    }

    print("🤖 MODÈLES GEMINI DISPONIBLES")
    print("=" * 35)

    for nom, info in modeles.items():
        print(f"\n📦 {nom}")
        print(f"   Taille: {info['taille']}")
        print(f"   Vitesse: {info['vitesse']}")
        print(f"   Qualité: {info['qualite']}")
        print(f"   Usage: {info['usage']}")

def verifier_installation():
    """Vérifie que toutes les dépendances sont installées"""

    print("🔧 VÉRIFICATION DE L'INSTALLATION")
    print("-" * 35)

    dependances = [
        ('pandas', 'pandas'),
        ('numpy', 'numpy'),
        ('transformers', 'transformers'),
        ('torch', 'torch'),
        ('sklearn', 'scikit-learn'),
        ('nltk', 'nltk'),
        ('PyPDF2', 'PyPDF2'),
        ('pdfplumber', 'pdfplumber')
    ]

    manquantes = []

    for module, nom_pip in dependances:
        try:
            __import__(module)
            print(f"✅ {module}")
        except ImportError:
            print(f"❌ {module} - Installer avec: pip install {nom_pip}")
            manquantes.append(nom_pip)

    if manquantes:
        print(f"\n💡 Commande d'installation complète:")
        print(f"pip install {' '.join(manquantes)}")
        return False
    else:
        print(f"\n✅ Toutes les dépendances sont installées!")
        return True

def aide_utilisation():
    """Affiche l'aide d'utilisation"""

    print("📖 GUIDE D'UTILISATION")
    print("=" * 25)

    print("\n🚀 UTILISATION BASIQUE:")
    print("```python")
    print("# Analyse complète avec paramètres par défaut")
    print("resultats = main('mon_rfp.pdf')")
    print("")
    print("# Avec paramètres personnalisés")
    print("resultats = main(")
    print("    chemin_rfp_pdf='rfp_beynost.pdf',")
    print("    chemin_dataset_csv='UpdatedResumeDataSet.csv',")
    print("    modele_gemini='google/gemma-7b-it',")
    print("    sauvegarder=True")
    print(")")
    print("```")

    print("\n🔍 ANALYSE RAPIDE RFP:")
    print("```python")
    print("# Prévisualisation rapide d'un RFP")
    print("rfp = analyser_rfp_simple('mon_rfp.pdf')")
    print("```")

    print("\n⚙️ FONCTIONS UTILES:")
    print("```python")
    print("# Vérifier l'installation")
    print("verifier_installation()")
    print("")
    print("# Lister les modèles disponibles")
    print("lister_modeles_gemini()")
    print("")
    print("# Afficher cette aide")
    print("aide_utilisation()")
    print("```")

    print("\n📁 STRUCTURE DES RÉSULTATS:")
    print("- resultats['rfp']: Analyse du RFP")
    print("- resultats['candidats_top']: Top candidats")
    print("- resultats['donnees_marche']: Analyse marché")
    print("- resultats['rapport_executif']: Rapport Gemini")
    print("- resultats['recommandation']: Decision finale")

def exemple_utilisation():
    """Exemples d'utilisation du système"""

    print("💡 EXEMPLES D'UTILISATION")
    print("=" * 30)

    print("\n1️⃣ ANALYSE COMPLÈTE BASIQUE:")
    print("   resultats = main('beynost_rfp.pdf')")

    print("\n2️⃣ AVEC MODÈLE PUISSANT:")
    print("   resultats = main('rfp_complexe.pdf', modele_gemini='google/gemma-7b-it')")

    print("\n3️⃣ PRÉVISUALISATION RFP:")
    print("   rfp = analyser_rfp_simple('nouveau_rfp.pdf')")

    print("\n4️⃣ ANALYSE SANS SAUVEGARDE:")
    print("   resultats = main('rfp_test.pdf', sauvegarder=False)")

    print("\n5️⃣ ACCÈS AUX RÉSULTATS:")
    print("   meilleur_candidat = resultats['candidats_top'][0]")
    print("   print(f'Score: {meilleur_candidat.score_match:.1%}')")

# ============================================================================
# POINT D'ENTRÉE PRINCIPAL
# ============================================================================

if __name__ == "__main__":
    print("🇫🇷 AGENT DE RECRUTEMENT FRANÇAIS AVEC GEMINI")
    print("=" * 50)
    print("📖 Tapez aide_utilisation() pour voir les exemples")
    print("🔧 Tapez verifier_installation() pour vérifier les dépendances")
    print("🤖 Tapez lister_modeles_gemini() pour voir les modèles")
    print("=" * 50)

    # Exemple d'utilisation par défaut (à personnaliser)
    print("\n💡 EXEMPLE D'UTILISATION:")
    print("resultats = main('votre_rfp.pdf', 'UpdatedResumeDataSet.csv')")
    print("\n🚀 Prêt à analyser vos RFPs français!")

# DÉCOMMENTEZ LA LIGNE CI-DESSOUS POUR LANCER UNE ANALYSE
resoudre_probleme_authentification()
resultats = main('/kaggle/input/recruitment-input/18_CCTP.pdf', '/kaggle/input/recruitment-input/UpdatedResumeDataSet.csv')

